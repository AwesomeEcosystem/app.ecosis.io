{"version":3,"sources":["webpack:///./src/helpers/account_helper.ts","webpack:///./src/js/wallets/MnemonicWallet.ts","webpack:///./src/js/ERC721Token.ts","webpack:///./src/js/AvaNetwork.ts","webpack:///./src/js/Erc20Token.ts","webpack:///./src/js/TxHelper.ts","webpack:///./src/js/Crypto.ts","webpack:///./src/js/Keystore.ts","webpack:///./src/explorer_api.ts","webpack:///./src/evm.ts","webpack:///./src/helpers/price_helper.ts","webpack:///./src/js/HdHelper.ts","webpack:///./src/js/wallets/HdWalletCore.ts","webpack:///./src/helpers/history_helper.ts","webpack:///./src/js/wallets/LedgerWallet.ts","webpack:///./src/locales/lang_map.js","webpack:///./src/js/wallets/MnemonicPhrase.ts","webpack:///./src/helpers/utxo_helper.ts","webpack:///./src/js/wallets/SingletonWallet.ts","webpack:///./src/js/AvaNftFamily.ts","webpack:///./src/js/wallets/WalletCore.ts","webpack:///./src/helpers/wallet_helper.ts","webpack:///./src/helpers/helper.ts","webpack:///./src/js/AvaAsset.ts"],"names":["getAccountByIndex","index","getLocalStorageAccounts","removeAccountByIndex","accounts","splice","saveLocalStorageJSONItem","getLocalStorageJSONItem","key","item","localStorage","getItem","JSON","parse","data","formatted","stringify","setItem","addAccountToStorage","account","push","verifyAccountPassword","password","wallet","overwriteAccountAtIndex","newAccount","accts","AVA_TOKEN_INDEX","AVA_ACCOUNT_PATH","ETH_ACCOUNT_PATH","LEDGER_ETH_ACCOUNT_PATH","mnemonic","seed","masterHdKey","fromMasterSeed","accountHdKey","derive","ethAccountKey","ethPrivateKey","privateKey","ethKey","toString","ethAddress","ethBalance","cPrivKey","cb58Encode","from","ethKeyBech","cKeyChain","getHRP","ethKeyChain","importKey","type","hdKey","isLoading","onnetworkchange","this","getEvmAddress","getEthBalance","bal","sendEth","to","amount","gasPrice","gasLimit","estimateGas","token","Promise","sendERC20","sendErc20","getUTXOs","isFetchUtxos","isInit","externalHelper","internalHelper","platformHelper","getStake","setTimeout","getCurrentKey","getMnemonic","getValue","getMnemonicEncrypted","validate","nodeID","amt","start","end","delegationFee","rewardAddress","utxos","delegate","stakeAmount","issueBatchTx","orders","addr","memo","getKeyChain","internal","getAllDerivedKeys","external","allKeys","concat","keychain","getNetworkID","chainId","i","length","addKey","signX","unsignedTx","tx","sign","signP","getKeychain","signC","keyChain","signEvm","keyBuff","Buffer","signHashByExternalIndex","hash","getKeyForIndex","signed","createNftFamily","name","symbol","groupNum","mintNft","mintUtxo","payload","quantity","ERC721MetadataID","ERC721EnumerableID","tokenCache","uriDataCache","canSupport","contractAddress","address","contract","eth","Contract","abi","updateSupports","methods","supportsInterface","call","metadata","enumerable","getBalance","balanceOf","getAllTokensIds","res","tokenOfOwnerByIndex","tokenId","getAllTokenData","ids","id","getTokenURI","parseInt","createTransferTx","transferFrom","tokenURI","getTokenURIData","uri","a","get","network_id","url","networkId","explorerUrl","explorerSiteUrl","readonly","withCredentials","protocol","port","ip","updateURL","testConnection","credentials","post","jsonrpc","method","catch","err","updateCredentials","split","includes","urlSplit","getFullURL","getWsUrlX","getWsUrlC","tokenData","balanceRaw","balanceBN","balanceBig","tokenInst","fromAddress","console","log","transfer","updateBalance","decimals","AvmTxNameEnum","PlatfromTxNameEnum","ParseableAvmTxEnum","ParseablePlatformEnum","ParseableEvmTxEnum","buildUnsignedTransaction","derivedAddresses","utxoset","changeAddress","fromAddrsStr","fromAddrs","map","val","parseAddress","changeAddr","stringToAddress","getAVAXAssetID","AVAX_ID_BUF","AVAX_ID_STR","TO_BUF","aad","ZERO","isFeeAdded","order","asset","assetId","cb58Decode","addAssetAmount","getTxFee","gt","success","getMinimumSpendable","ins","outs","getInputs","getAllOutputs","nftUtxos","filter","getBlockchainID","nftSet","addArray","utxoIds","getUTXOIDs","sort","b","buildNFTTransferTx","undefined","rawTx","getTransaction","outsNft","getOuts","insNft","getIns","baseTx","buildCreateNftFamilyTx","minterAddr","utxoSet","fromAddresses","minterAddress","minterSets","minterSet","buildCreateNFTAssetTx","buildMintNftTx","ownerAddress","addrBuf","owners","sourceAddresses","owner","groupID","getOutput","getGroupID","buildCreateNFTMintTx","getUTXOID","mintTx","buildEvmTransferNativeTx","getTransactionCount","nonce","getChainId","net","getId","chainParams","common","forCustomChain","value","buildEvmTransferErc20Tx","tokenTx","encodeABI","buildEvmTransferErc721Tx","BASETX","CREATEASSETTX","OPERATIONTX","IMPORTTX","EXPORTTX","ADDVALIDATORTX","ADDDELEGATORTX","ADDSUBNETVALIDATORTX","CREATECHAINTX","CREATESUBNETTX","ADVANCETIMETX","REWARDVALIDATORTX","ivSize","saltSize","tagLength","aesLength","keygenIterations","_pwcleaner","slt","pw","sha256","_keyMaterial","pwkey","window","crypto","subtle","Uint8Array","_deriveKey","keyMaterial","salt","deriveKey","iterations","message","buff","update","digest","makeSalt","alloc","getRandomValues","pwhash","encrypt","plaintext","pt","pkey","iv","additionalData","ciphertext","decrypt","cryptoHelpers","Crypto","KEYSTORE_VERSION","ITERATIONS_V2","ITERATIONS_V3","readV2","pass","version","pass_hash","checkHash","checkHashString","keys","keysDecrypt","key_data","key_decrypt","key_string","activeIndex","readV3","readV4","readV5","readV6","readKeyFile","extractKeysV2","file","chainID","getBlockchainAlias","pk","keypair","keyBuf","getPrivateKey","keyHex","paddedKeyHex","padStart","extractKeysV5","extractKeysV6","extractKeysFromDecryptedFile","makeKeyfile","wallets","pk_crypt","file_data","api_url","explorer_api","create","baseURL","headers","getAddressHistory","addrs","limit","endTime","ADDR_SIZE","selection","slice","remaining","addrsRaw","rootUrl","req","disableCount","disableGenesis","txs","transactions","next","nextRes","getAddressChains","rawAddrs","urlRoot","addressChains","abiDecoder","addABI","rpcUrl","web3","axios","COIN_ID","COINGECKO_URL","coingeckoApi","timeout","getAvaxPriceUSD","priceHistory","getPriceHistory","params","vs_currency","days","interval","prices","getPriceAtUnixTime","time","remainder","dayTimestamp","pricePair","find","INDEX_RANGE","SCAN_SIZE","SCAN_RANGE","changePath","masterKey","isPublic","isFetchUtxo","hrp","keyCache","addressCache","hdCache","hdIndex","oninit","findHdIndex","onNetworkChange","clearCache","incrementIndex","newIndex","newKey","network","store","state","Network","selectedNetwork","findAvailableIndexExplorer","findAvailableIndexNode","updateKeychain","updateUtxos","error","getAllDerivedAddresses","result","currentAddr","getCurrentAddress","currentAddrBuf","currentUtxos","getExtendedAddresses","getUtxos","upTo","set","getAddressForIndex","startIndex","addrChains","gapSize","n","scanIndex","scanAddr","rawAddr","chains","addrUTXOs","targetIndex","getFirstAvailableIndex","getFirstAvailableAddress","idx","isPrivate","cacheExternal","pkHex","derivationPath","publicKey","pkBuf","pkBuff","addressFromPublicKey","addressToString","findAddressIndex","indexOf","ethHdNode","then","updateInitState","getEvmAddressBech","pubKeyHash","updateAvmUTXOSet","setExternal","setInternal","joined","merge","getFirstAvailableAddressPlatform","updateFetchState","updateUTXOsX","updateUTXOsP","updateUTXOsExternal","updateUTXOsInternal","getAllDerivedExternalAddresses","getDerivedAddresses","getDerivedAddressesP","getAllAddressesX","getAllAddressesP","getHistoryAddresses","internalIndex","externalIndex","Math","max","getCurrentAddressAvm","getChangeAddressAvm","getChangeAddressPlatform","getChangePath","getChangeIndex","getChangeFromIndex","getPlatformRewardAddress","getCurrentAddressPlatform","getPlatformUTXOSet","getPlatformActiveIndex","getExternalActiveIndex","getBaseAddress","getUTXOSet","findExternalAddressIndex","indexX","indexP","Error","signMessageByExternalAddress","msgStr","signMessageByExternalIndex","digestHex","digestBuff","signMessage","msg","WalletCore","addToDict","dict","utxo","addresses","add","addrDiff","getNFTsSummary","nftLoss","getLossNFT","nftGain","getGainNFT","sent","received","walletAddrs","addrsStripped","inputs","outputs","loss","assets","nfts","input","output","outputType","NFTXFEROUTPUTID","nftsOuts","assetID","intersect","nftOut","doesMatch","addrNotAdded","gain","nftsIns","nftIn","getLoss","isNft","amountBN","receivers","forEach","outAddrs","targets","getProfit","profit","senders","getTransactionSummary","losses","profits","nftSummary","sum","tokens","collectibles","mul","filterDuplicateTransactions","txsIds","filtered","txId","bippath","MIN_EVM_SUPPORT_V","app","hdkey","config","hdEth","ethApp","ethPublic","fromApp","getWalletExtendedPublicKey","hd","public_key","chainCode","chain_code","getAddress","ethRes","LedgerWallet","getTransactionPaths","toBuffer","txType","getTxType","operations","getOperations","e","items","getImportInputs","paths","isAvaxOnly","getAssetID","Assets","AVA_ASSET_ID","sigidxs","getInput","getSigIdxs","sources","sigidx","source","j","srcAddr","pathStr","getPathFromAddress","op","getOperation","pathsToUniqueBipPaths","uniquePaths","bip32Paths","path","fromString","getChangeBipPath","chainChangePath","changeIdx","getCredentials","sigMap","CredentialClass","creds","evmInputs","cred","getCredentialID","pathIndex","sigRaw","sigBuff","sig","fromBuffer","addSignature","evmInput","signTransactionHash","txbuff","commit","title","messages","info","toUpperCase","accountPathSource","accountPath","signHash","signedTx","signTransactionParsable","parseableTxs","X","P","C","getTransactionMessages","signTransaction","ledgerSignedTx","signatures","getOutputMsgs","getExportOutputs","getExportedOutputs","destinationChain","getAmount","toPathArray","getAddresses","getValidateDelegateMsgs","format","getNodeID","startTime","getStartTime","toNumber","utc","getEndTime","stakeAmt","getStakeAmount","rewardOwners","getRewardOwners","rewardAddrs","join","getFeeMsgs","outputMessages","validateDelegateMessages","feeMessages","getEvmTransactionMessages","totFee","feeNano","bnToBig","msgs","test","decodeMethod","callMsg","paramMsgs","param","feeMsg","toLocaleString","canLedgerParse","isParsableType","txIns","typeID","getTypeID","STAKEABLELOCKINID","destChainBuff","getDestinationChain","destChain","idToChainAlias","sourceChainBuff","getSourceChain","sourceChain","typeId","txSigned","rawUnsignedTx","encode","buf","signature","signatureBN","v","r","s","fromTxData","externalAddrs","internalAddrs","platformAddrs","extIndex","intIndex","platformIndex","addressPath","isoLangs","ab","nativeName","aa","af","ak","sq","am","ar","an","hy","as","av","ae","ay","az","bm","ba","eu","be","bn","bh","bi","bs","br","bg","my","ca","ch","ce","ny","cn","zh_hans","zh_hant","cv","kw","co","cr","hr","cs","da","dv","nl","en","eo","et","ee","fo","fj","fi","fr","ff","gl","ka","de","el","gn","gu","ht","ha","he","hz","hi","ho","hu","ia","ie","ga","ig","ik","io","is","it","iu","ja","jv","kl","kn","ks","kk","km","ki","rw","ky","kv","kg","kr","ku","kj","la","lb","lg","li","ln","lo","lt","lu","lv","gv","mk","mg","ms","ml","mt","mi","mr","mh","mn","na","nv","nb","nd","ne","ng","nn","no","ii","nr","oc","oj","cu","om","or","os","pa","pi","fa","pl","ps","qu","rm","rn","ro","ru","sa","sc","sd","se","sm","sg","sr","gd","sn","si","sk","sl","so","st","es","su","sw","ss","sv","ta","te","tg","th","ti","bo","tk","tl","tn","tr","ts","tt","tw","ty","ug","uk","ur","uz","ve","vn","vo","wa","cy","wo","fy","xh","yi","yo","za","randomstring","generate","encrypted","decrypted","enc","Utf8","getStakeForAddresses","stakeData","staked","chunk","remainingChunk","chunkStake","avmGetAllUTXOs","avmGetAllUTXOsForAddresses","newSet","endIndex","response","getAllUTXOs","nextEndIndex","len","numFetched","subUtxos","platformGetAllUTXOs","platformGetAllUTXOsForAddresses","chainIdP","keyPair","platformKeyChain","platformKeyPair","pkBuffNative","cKeypair","ethAddressBech","getAddressString","getExtendedPlatformAddresses","platformUtxoset","uniqid","evmGetAtomicUTXOs","createImportTxC","fee","bechAddr","hexAddr","toAddress","ownerAddresses","sourceChainId","chainIdFromAlias","buildImportTx","importToCChain","unsignedTxFee","issueTx","exportFromXChain","importFee","amtFee","clone","destinationAddr","buildAvmExportTransaction","exportTx","exportFromPChain","pChangeAddr","buildPlatformExportTransaction","exportFromCChain","exportFee","buildEvmExportTransaction","estimateExportFee","estimateExportGasFee","avmGetAtomicUTXOs","platformGetAtomicUTXOs","importToPlatformChain","pToAddr","utxoAddrs","ownerAddrs","importToXChain","xToAddr","pAddressStrings","stakeReturnAddr","round","getTime","buildAddValidatorTx","buildAddDelegatorTx","fromAddr","txHex","serialize","sendSignedTransaction","transactionHash","sendErc721","estimateTxGas","estGas","denomination","div","pow","keyToKeypair","calculateStakingReward","duration","currentSupply","networkID","defValues","defPlatformVals","maxConsumption","minConsumption","diffConsumption","maxSupply","maxStakingDuration","remainingSupply","sub","amtBig","currentSupplyBig","remainingSupplyBig","portionOfExistingSupplyBig","portionOfStakingDuration","mintingRate","rewardBig","times","rewardStr","toFixed","rewardBN","digestMessage","mBuf","msgSize","writeUInt32BE","msgBuf","payloadtypes","getInstance","getPayloadFromUTXO","out","getPayloadBuffer","getContent","payloadbase","select","amountLocked","amountExtra","addBalance","addBalanceLocked","addExtra","resetBalance","locked","getAmountBN","getTotalAmount","toStringTotal","big"],"mappings":"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","file":"js/app~63defed8.b23a43ef.js","sourcesContent":["import { iUserAccountEncrypted } from '@/store/types'\nimport { WalletType } from '@/js/wallets/types'\nimport isEqual from 'lodash.isequal'\nimport differenceBy from 'lodash.differenceby'\nimport { readKeyFile } from '@/js/Keystore'\n\nconst checkAccountsExist = (): boolean => {\n    return localStorage.getItem('accounts') !== null\n}\n\nexport function getAccountByIndex(index: number): iUserAccountEncrypted | null {\n    return getLocalStorageAccounts()[index] || null\n}\n\nexport const checkIfSavedLocally = (allWallets: WalletType[]): boolean => {\n    const exists = checkAccountsExist()\n\n    if (!exists) return false\n\n    let ethAddressArray: string[] = allWallets.map((x: WalletType) => x.ethAddress)\n\n    const savedAccounts: iUserAccountEncrypted[] = getLocalStorageJSONItem('accounts')\n\n    for (const each of savedAccounts) {\n        if (isEqual(each.baseAddresses, ethAddressArray)) {\n            return true\n        }\n    }\n\n    return false\n}\nexport const removeAccountByIndex = (index: number): void => {\n    const accounts: iUserAccountEncrypted[] = getLocalStorageAccounts()\n    accounts.splice(index, 1)\n    saveLocalStorageJSONItem('accounts', accounts)\n}\n\nexport const getLocalStorageJSONItem = (key: string) => {\n    let item = localStorage.getItem(key)\n    if (item !== null) {\n        return JSON.parse(item)\n    }\n}\n\nexport function getLocalStorageAccounts(): iUserAccountEncrypted[] {\n    return getLocalStorageJSONItem('accounts') || []\n}\n\nexport const saveLocalStorageJSONItem = (key: string, data: any) => {\n    let formatted = JSON.stringify(data)\n    localStorage.setItem(key, formatted)\n}\n\nexport const getIndexByWallets = (wallets: WalletType[]): number | null => {\n    let ethAddressArray: string[] = wallets.map((x: WalletType) => x.getEvmAddress())\n    const savedAccounts: iUserAccountEncrypted[] = getLocalStorageAccounts()\n    let index = 0\n    for (var i = 0; i < savedAccounts.length; i++) {\n        let acct = savedAccounts[i]\n        if (isEqual(acct.baseAddresses, ethAddressArray)) {\n            return index\n        }\n    }\n    return null\n}\n\nexport const getNonVolatileWallets = (\n    allWallets: WalletType[],\n    volatileWallets: WalletType[]\n): WalletType[] | [] => {\n    let diff = differenceBy(allWallets, volatileWallets, 'ethAddress')\n    diff === undefined ? [] : diff\n    return diff\n}\n\nexport function addAccountToStorage(account: iUserAccountEncrypted) {\n    let accounts = getLocalStorageAccounts()\n    accounts.push(account)\n    saveLocalStorageJSONItem('accounts', accounts)\n}\n\n// Given a password and an account, will verify if its the correct password\nexport async function verifyAccountPassword(account: iUserAccountEncrypted, password: string) {\n    try {\n        let res = await readKeyFile(account.wallet, password)\n        return true\n    } catch (err) {\n        return false\n    }\n}\n\nexport function overwriteAccountAtIndex(newAccount: iUserAccountEncrypted, index: number) {\n    let accts = getLocalStorageAccounts()\n    accts.splice(index, 1, newAccount)\n    saveLocalStorageJSONItem('accounts', accts)\n}\n\nexport default {\n    removeAccountByIndex,\n    checkIfSavedLocally,\n    getNonVolatileWallets,\n}\n","// A simple wrapper thar combines avalanche.js, bip39 and HDWallet\n\nimport {\n    KeyPair as AVMKeyPair,\n    KeyChain as AVMKeyChain,\n    UTXOSet as AVMUTXOSet,\n    TransferableInput,\n    TransferableOutput,\n    BaseTx,\n    UnsignedTx as AVMUnsignedTx,\n    Tx as AVMTx,\n    UTXO as AVMUTXO,\n    AssetAmountDestination,\n    UTXOSet,\n} from 'avalanche/dist/apis/avm'\n\nimport { privateToAddress } from 'ethereumjs-util'\n\nimport {\n    KeyChain as PlatformVMKeyChain,\n    UnsignedTx as PlatformUnsignedTx,\n    UTXO as PlatformUTXO,\n    Tx as PlatformTx,\n} from 'avalanche/dist/apis/platformvm'\n\nimport {\n    KeyChain as EVMKeyChain,\n    UnsignedTx as EVMUnsignedTx,\n    Tx as EvmTx,\n} from 'avalanche/dist/apis/evm'\nimport { getPreferredHRP, PayloadBase } from 'avalanche/dist/utils'\n\nimport * as bip39 from 'bip39'\nimport { BN, Buffer as BufferAvalanche } from 'avalanche'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { AvmExportChainType, AvmImportChainType, IAvaHdWallet } from '@/js/wallets/types'\nimport HDKey from 'hdkey'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { KeyPair as PlatformVMKeyPair } from 'avalanche/dist/apis/platformvm'\nimport { HdWalletCore } from '@/js/wallets/HdWalletCore'\nimport { WalletNameType } from '@/js/wallets/types'\nimport { digestMessage } from '@/helpers/helper'\nimport { KeyChain } from 'avalanche/dist/apis/evm'\nimport Erc20Token from '@/js/Erc20Token'\nimport { WalletHelper } from '@/helpers/wallet_helper'\nimport { Transaction } from '@ethereumjs/tx'\nimport MnemonicPhrase from '@/js/wallets/MnemonicPhrase'\nimport { ExportChainsC, ExportChainsP } from '@avalabs/avalanche-wallet-sdk'\n\n// HD WALLET\n// Accounts are not used and the account index is fixed to 0\n// m / purpose' / coin_type' / account' / change / address_index\n\nconst AVA_TOKEN_INDEX: string = '9000'\nexport const AVA_ACCOUNT_PATH: string = `m/44'/${AVA_TOKEN_INDEX}'/0'` // Change and index left out\nexport const ETH_ACCOUNT_PATH: string = `m/44'/60'/0'`\nexport const LEDGER_ETH_ACCOUNT_PATH = ETH_ACCOUNT_PATH + '/0/0'\n\nconst INDEX_RANGE: number = 20 // a gap of at least 20 indexes is needed to claim an index unused\nconst SCAN_SIZE: number = 70 // the total number of utxos to look at initially to calculate last index\nconst SCAN_RANGE: number = SCAN_SIZE - INDEX_RANGE // How many items are actually scanned\n\n// Possible indexes for each request is\n// SCAN_SIZE - INDEX_RANGE\n\nexport default class MnemonicWallet extends HdWalletCore implements IAvaHdWallet {\n    seed: string\n    hdKey: HDKey\n    private mnemonic: MnemonicPhrase\n    isLoading: boolean\n    type: WalletNameType\n    ethKey: string\n    ethKeyBech: string\n    ethKeyChain: EVMKeyChain\n    ethAddress: string\n    ethBalance: BN\n\n    // TODO : Move to hd core class\n    onnetworkchange() {\n        super.onnetworkchange()\n\n        // Update EVM values\n        this.ethKeyChain = new EVMKeyChain(ava.getHRP(), 'C')\n        let cKeypair = this.ethKeyChain.importKey(this.ethKeyBech)\n        this.ethBalance = new BN(0)\n    }\n\n    // The master key from avalanche.js\n    constructor(mnemonic: string) {\n        let seed: globalThis.Buffer = bip39.mnemonicToSeedSync(mnemonic)\n        let masterHdKey: HDKey = HDKey.fromMasterSeed(seed)\n        let accountHdKey = masterHdKey.derive(AVA_ACCOUNT_PATH)\n        let ethAccountKey = masterHdKey.derive(ETH_ACCOUNT_PATH + '/0/0')\n\n        super(accountHdKey, ethAccountKey, false)\n\n        // Derive EVM key and address\n        let ethPrivateKey = ethAccountKey.privateKey\n        this.ethKey = ethPrivateKey.toString('hex')\n        this.ethAddress = privateToAddress(ethPrivateKey).toString('hex')\n        this.ethBalance = new BN(0)\n\n        let cPrivKey = `PrivateKey-` + bintools.cb58Encode(BufferAvalanche.from(ethPrivateKey))\n        this.ethKeyBech = cPrivKey\n\n        let cKeyChain = new KeyChain(ava.getHRP(), 'C')\n        this.ethKeyChain = cKeyChain\n\n        let cKeypair = cKeyChain.importKey(cPrivKey)\n\n        this.type = 'mnemonic'\n        this.seed = seed.toString('hex')\n        this.hdKey = masterHdKey\n        this.mnemonic = new MnemonicPhrase(mnemonic)\n        this.isLoading = false\n    }\n\n    getEvmAddress(): string {\n        return this.ethAddress\n    }\n\n    async getEthBalance() {\n        let bal = await WalletHelper.getEthBalance(this)\n        this.ethBalance = bal\n        return bal\n    }\n\n    async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n        return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit)\n    }\n\n    async estimateGas(to: string, amount: BN, token: Erc20Token): Promise<number> {\n        return await WalletHelper.estimateGas(this, to, amount, token)\n    }\n\n    async sendERC20(\n        to: string,\n        amount: BN,\n        gasPrice: BN,\n        gasLimit: number,\n        token: Erc20Token\n    ): Promise<string> {\n        return await WalletHelper.sendErc20(this, to, amount, gasPrice, gasLimit, token)\n    }\n\n    async getUTXOs(): Promise<void> {\n        // TODO: Move to shared file\n        this.isFetchUtxos = true\n        // If we are waiting for helpers to initialize delay the call\n        let isInit =\n            this.externalHelper.isInit && this.internalHelper.isInit && this.platformHelper.isInit\n        if (!isInit) {\n            setTimeout(() => {\n                this.getUTXOs()\n            }, 1000)\n            return\n        }\n\n        super.getUTXOs()\n        this.getStake()\n        this.getEthBalance()\n        return\n    }\n\n    getCurrentKey(): AVMKeyPair {\n        return this.externalHelper.getCurrentKey() as AVMKeyPair\n    }\n\n    /**\n     * Returns the mnemonic phrase of this wallet\n     */\n    getMnemonic(): string {\n        return this.mnemonic.getValue()\n    }\n\n    getMnemonicEncrypted(): MnemonicPhrase {\n        return this.mnemonic\n    }\n\n    async validate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number = 0,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.validate(\n            this,\n            nodeID,\n            amt,\n            start,\n            end,\n            delegationFee,\n            rewardAddress,\n            utxos\n        )\n    }\n\n    // Delegates AVAX to the given node ID\n    async delegate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.delegate(this, nodeID, amt, start, end, rewardAddress, utxos)\n    }\n\n    async getStake(): Promise<BN> {\n        this.stakeAmount = await WalletHelper.getStake(this)\n        return this.stakeAmount\n    }\n\n    async issueBatchTx(\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: BufferAvalanche | undefined\n    ): Promise<string> {\n        return await WalletHelper.issueBatchTx(this, orders, addr, memo)\n    }\n\n    // returns a keychain that has all the derived private/public keys for X chain\n    getKeyChain(): AVMKeyChain {\n        let internal = this.internalHelper.getAllDerivedKeys() as AVMKeyPair[]\n        let external = this.externalHelper.getAllDerivedKeys() as AVMKeyPair[]\n\n        let allKeys = internal.concat(external)\n        let keychain: AVMKeyChain = new AVMKeyChain(\n            getPreferredHRP(ava.getNetworkID()),\n            this.chainId\n        )\n\n        for (var i = 0; i < allKeys.length; i++) {\n            keychain.addKey(allKeys[i])\n        }\n        return keychain\n    }\n\n    async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n        let keychain = this.getKeyChain()\n\n        const tx = unsignedTx.sign(keychain)\n        return tx\n    }\n\n    async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n        let keychain = this.platformHelper.getKeychain() as PlatformVMKeyChain\n        const tx = unsignedTx.sign(keychain)\n        return tx\n    }\n\n    async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n        let keyChain = this.ethKeyChain\n        return unsignedTx.sign(keyChain)\n    }\n\n    async signEvm(tx: Transaction) {\n        let keyBuff = Buffer.from(this.ethKey, 'hex')\n        return tx.sign(keyBuff)\n    }\n\n    async signHashByExternalIndex(index: number, hash: BufferAvalanche) {\n        let key = this.externalHelper.getKeyForIndex(index) as AVMKeyPair\n        let signed = key.sign(hash)\n        return bintools.cb58Encode(signed)\n    }\n\n    async createNftFamily(name: string, symbol: string, groupNum: number) {\n        return await WalletHelper.createNftFamily(this, name, symbol, groupNum)\n    }\n\n    async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n        return await WalletHelper.mintNft(this, mintUtxo, payload, quantity)\n    }\n}\n","import { web3 } from '@/evm'\nimport ERC721Abi from '@openzeppelin/contracts/build/contracts/ERC721.json'\nimport { ERC721TokenInput } from '@/store/modules/assets/modules/types'\nimport axios from 'axios'\nimport { BN } from 'avalanche'\n\ninterface TokenDataCache {\n    [index: number]: string\n}\n\ninterface URIDataCache {\n    [index: number]: string\n}\n\nconst ERC721MetadataID = '0x5b5e139f'\nconst ERC721EnumerableID = '0x780e9d63'\n\nclass ERC721Token {\n    contractAddress: string\n    contract: any\n    name = ''\n    symbol = ''\n    data: ERC721TokenInput\n    tokenCache: TokenDataCache = {}\n    uriDataCache: URIDataCache = {}\n    canSupport = false\n\n    constructor(data: ERC721TokenInput) {\n        this.contractAddress = data.address\n        this.name = data.name\n        this.symbol = data.symbol\n        this.data = data\n        //@ts-ignore\n        this.contract = new web3.eth.Contract(ERC721Abi.abi, this.contractAddress)\n        this.updateSupports()\n    }\n\n    async updateSupports() {\n        try {\n            let metadata = await this.contract.methods.supportsInterface(ERC721MetadataID).call()\n            let enumerable = await this.contract.methods\n                .supportsInterface(ERC721EnumerableID)\n                .call()\n            this.canSupport = metadata && enumerable\n        } catch (err) {\n            this.canSupport = false\n            // console.error(err)\n        }\n    }\n\n    async getBalance(address: string) {\n        return await this.contract.methods.balanceOf(address).call()\n    }\n\n    async getAllTokensIds(address: string): Promise<string[]> {\n        if (!this.canSupport) return []\n\n        let bal = await this.getBalance(address)\n        let res = []\n        for (var i = 0; i < bal; i++) {\n            let tokenId = await this.contract.methods.tokenOfOwnerByIndex(address, i).call()\n            res.push(tokenId)\n        }\n        return res\n    }\n\n    async getAllTokenData(address: string) {\n        let ids = await this.getAllTokensIds(address)\n\n        let res = []\n        for (var i = 0; i < ids.length; i++) {\n            let id = ids[i]\n            let data = await this.getTokenURI(parseInt(id))\n            res.push(data)\n        }\n        return res\n    }\n\n    createTransferTx(from: string, to: string, id: string) {\n        return this.contract.methods.transferFrom(from, to, id)\n    }\n\n    async getTokenURI(id: number) {\n        if (this.tokenCache[id]) return this.tokenCache[id]\n        let data = await this.contract.methods.tokenURI(id).call()\n        this.tokenCache[id] = data\n        return data\n    }\n\n    async getTokenURIData(id: number): Promise<any> {\n        //Check cache\n        if (this.uriDataCache[id]) return this.uriDataCache[id]\n        let uri = await this.getTokenURI(id)\n        if (!uri) return null\n        let res = (await axios.get(uri)).data\n        //Save to cache\n        this.uriDataCache[id] = res\n        return res\n    }\n}\n\nexport default ERC721Token\n","import axios from 'axios'\n\nlet network_id: number = 0\n\nclass AvaNetwork {\n    name: string\n    id: number\n    protocol: string\n    port: number\n    ip: string\n    networkId: number\n    // chainId: string;\n    url: string\n    explorerUrl: string | undefined\n    explorerSiteUrl: string | undefined\n    readonly: boolean\n    withCredentials = false\n    // fee: BN\n\n    constructor(\n        name: string,\n        url: string,\n        networkId: number,\n        explorerUrl?: string,\n        explorerSiteUrl?: string,\n        readonly = false\n    ) {\n        this.id = network_id++\n        this.name = name\n        this.explorerUrl = explorerUrl\n        this.explorerSiteUrl = explorerSiteUrl\n        this.protocol = 'http'\n        this.port = 9650\n        this.ip = 'localhost'\n        this.url = url\n        this.updateURL(url)\n        this.networkId = networkId\n        // this.chainId = chainId;\n        this.readonly = readonly\n        // this.fee = new BN(0);\n    }\n\n    async testConnection(credentials = false) {\n        let resp = await axios\n            .post(\n                this.url + '/ext/info',\n                {\n                    jsonrpc: '2.0',\n                    id: 1,\n                    method: 'info.getNetworkID',\n                },\n                {\n                    withCredentials: true,\n                }\n            )\n            .catch((err) => {\n                return false\n            })\n\n        return true\n    }\n\n    // Checks if this network endpoint allows credentials\n    async updateCredentials() {\n        try {\n            let res = await axios.post(\n                this.url + '/ext/info',\n                {\n                    jsonrpc: '2.0',\n                    id: 1,\n                    method: 'info.getNetworkID',\n                },\n                {\n                    withCredentials: true,\n                }\n            )\n            this.withCredentials = true\n        } catch (e) {\n            this.withCredentials = false\n        }\n    }\n\n    updateURL(url: string) {\n        let split: string[] = url.split('://')\n\n        this.protocol = split[0]\n\n        // port is set\n        if (split[1].includes(':')) {\n            let urlSplit: string[] = split[1].split(':')\n            let ip: string = urlSplit[0]\n            let port: string = urlSplit[1]\n\n            this.ip = ip\n            this.port = parseInt(port)\n        } else {\n            this.ip = split[1]\n            if (this.protocol === 'http') {\n                this.port = 80\n            } else {\n                this.port = 443\n            }\n        }\n    }\n    getFullURL() {\n        return `${this.protocol}://${this.ip}:${this.port}`\n    }\n\n    getWsUrlX(): string {\n        let protocol = this.protocol === 'https' ? 'wss' : 'ws'\n        return `${protocol}://${this.ip}:${this.port}/ext/bc/X/events`\n    }\n\n    getWsUrlC(): string {\n        let protocol = this.protocol === 'https' ? 'wss' : 'ws'\n        return `${protocol}://${this.ip}:${this.port}/ext/bc/C/ws`\n    }\n}\n\nexport { AvaNetwork }\n","import { TokenListToken } from '@/store/modules/assets/types'\nimport { web3 } from '@/evm'\nimport { BN } from 'avalanche'\nimport { bnToBig } from '@/helpers/helper'\nimport Big from 'big.js'\nimport store from '@/store'\n\nimport ERC20Abi from '@openzeppelin/contracts/build/contracts/ERC20.json'\n\nclass Erc20Token {\n    data: TokenListToken\n    contract: any\n    balanceRaw: string\n    balanceBN: BN\n    balanceBig: Big\n\n    constructor(tokenData: TokenListToken) {\n        this.data = tokenData\n        this.balanceRaw = '0'\n        this.balanceBN = new BN('0')\n        this.balanceBig = Big(0)\n\n        //@ts-ignore\n        var tokenInst = new web3.eth.Contract(ERC20Abi.abi, tokenData.address)\n        this.contract = tokenInst\n    }\n\n    // Returns a new instance of the token, given only the erc20 address\n    static fromAddress(address: string) {\n        //@ts-ignore\n        var tokenInst = new web3.eth.Contract(ERC20Abi.abi, address)\n        console.log(tokenInst)\n    }\n\n    createTransferTx(to: string, amount: BN) {\n        return this.contract.methods.transfer(to, amount.toString())\n    }\n\n    async updateBalance(address: string) {\n        let bal = await this.contract.methods.balanceOf('0x' + address).call()\n        this.balanceRaw = bal\n        this.balanceBN = new BN(bal)\n        this.balanceBig = bnToBig(this.balanceBN, parseInt(this.data.decimals as string))\n    }\n}\n\nexport default Erc20Token\n","import { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { BN, Buffer } from 'avalanche'\nimport {\n    AssetAmountDestination,\n    BaseTx,\n    MinterSet,\n    NFTMintOutput,\n    TransferableInput,\n    TransferableOutput,\n    UnsignedTx as AVMUnsignedTx,\n    UTXO as AVMUTXO,\n    UTXOSet,\n    UTXOSet as AVMUTXOSet,\n    AVMConstants,\n} from 'avalanche/dist/apis/avm'\n\nimport { PayloadBase } from 'avalanche/dist/utils'\nimport { OutputOwners } from 'avalanche/dist/common'\nimport { PlatformVMConstants } from 'avalanche/dist/apis/platformvm'\n\nimport { UnsignedTx as EVMUnsignedTx, EVMConstants } from 'avalanche/dist/apis/evm'\n\nimport { web3 } from '@/evm'\nimport ERC721Token from '@/js/ERC721Token'\nimport { Transaction } from '@ethereumjs/tx'\nimport EthereumjsCommon from '@ethereumjs/common'\nimport Erc20Token from '@/js/Erc20Token'\n\nexport async function buildUnsignedTransaction(\n    orders: (ITransaction | AVMUTXO)[],\n    addr: string,\n    derivedAddresses: string[],\n    utxoset: AVMUTXOSet,\n    changeAddress?: string,\n    memo?: Buffer\n) {\n    // TODO: Get new change index.\n    if (!changeAddress) {\n        throw 'Unable to issue transaction. Ran out of change index.'\n    }\n\n    let fromAddrsStr: string[] = derivedAddresses\n    let fromAddrs: Buffer[] = fromAddrsStr.map((val) => bintools.parseAddress(val, 'X'))\n    let changeAddr: Buffer = bintools.stringToAddress(changeAddress)\n\n    // TODO: use internal asset ID\n    // This does not update on network change, causing issues\n    const AVAX_ID_BUF = await avm.getAVAXAssetID()\n    const AVAX_ID_STR = AVAX_ID_BUF.toString('hex')\n    const TO_BUF = bintools.stringToAddress(addr)\n\n    const aad: AssetAmountDestination = new AssetAmountDestination([TO_BUF], fromAddrs, [\n        changeAddr,\n    ])\n    const ZERO = new BN(0)\n    let isFeeAdded = false\n\n    // Aggregate Fungible ins & outs\n    for (let i: number = 0; i < orders.length; i++) {\n        let order: ITransaction | AVMUTXO = orders[i]\n\n        if ((order as ITransaction).asset) {\n            // if fungible\n            let tx: ITransaction = order as ITransaction\n\n            let assetId = bintools.cb58Decode(tx.asset.id)\n            let amt: BN = tx.amount\n\n            if (assetId.toString('hex') === AVAX_ID_STR) {\n                aad.addAssetAmount(assetId, amt, avm.getTxFee())\n                isFeeAdded = true\n            } else {\n                aad.addAssetAmount(assetId, amt, ZERO)\n            }\n        }\n    }\n\n    // If fee isn't added, add it\n    if (!isFeeAdded) {\n        if (avm.getTxFee().gt(ZERO)) {\n            aad.addAssetAmount(AVAX_ID_BUF, ZERO, avm.getTxFee())\n        }\n    }\n\n    const success: Error = utxoset.getMinimumSpendable(aad)\n\n    let ins: TransferableInput[] = []\n    let outs: TransferableOutput[] = []\n    if (typeof success === 'undefined') {\n        ins = aad.getInputs()\n        outs = aad.getAllOutputs()\n    } else {\n        throw success\n    }\n\n    //@ts-ignore\n    let nftUtxos: UTXO[] = orders.filter((val) => {\n        if ((val as ITransaction).asset) return false\n        return true\n    })\n\n    // If transferring an NFT, build the transaction on top of an NFT tx\n    let unsignedTx: AVMUnsignedTx\n    let networkId: number = ava.getNetworkID()\n    let chainId: Buffer = bintools.cb58Decode(avm.getBlockchainID())\n\n    if (nftUtxos.length > 0) {\n        let nftSet = new AVMUTXOSet()\n        nftSet.addArray(nftUtxos)\n\n        let utxoIds: string[] = nftSet.getUTXOIDs()\n\n        // Sort nft utxos\n        utxoIds.sort((a, b) => {\n            if (a < b) {\n                return -1\n            } else if (a > b) {\n                return 1\n            }\n            return 0\n        })\n\n        unsignedTx = nftSet.buildNFTTransferTx(\n            networkId,\n            chainId,\n            [TO_BUF],\n            fromAddrs,\n            fromAddrs, // change address should be something else?\n            utxoIds,\n            undefined,\n            undefined,\n            memo\n        )\n\n        let rawTx = unsignedTx.getTransaction()\n        let outsNft = rawTx.getOuts()\n        let insNft = rawTx.getIns()\n\n        // TODO: This is a hackish way of doing this, need methods in avalanche.js\n        //@ts-ignore\n        rawTx.outs = outsNft.concat(outs)\n        //@ts-ignore\n        rawTx.ins = insNft.concat(ins)\n    } else {\n        let baseTx: BaseTx = new BaseTx(networkId, chainId, outs, ins, memo)\n        unsignedTx = new AVMUnsignedTx(baseTx)\n    }\n    return unsignedTx\n}\n\nexport async function buildCreateNftFamilyTx(\n    name: string,\n    symbol: string,\n    groupNum: number,\n    fromAddrs: string[],\n    minterAddr: string,\n    changeAddr: string,\n    utxoSet: UTXOSet\n) {\n    let fromAddresses = fromAddrs\n    let changeAddress = changeAddr\n    let minterAddress = minterAddr\n\n    const minterSets: MinterSet[] = []\n\n    // Create the groups\n    for (var i = 0; i < groupNum; i++) {\n        const minterSet: MinterSet = new MinterSet(1, [minterAddress])\n        minterSets.push(minterSet)\n    }\n\n    let unsignedTx: AVMUnsignedTx = await avm.buildCreateNFTAssetTx(\n        utxoSet,\n        fromAddresses,\n        [changeAddress],\n        minterSets,\n        name,\n        symbol\n    )\n    return unsignedTx\n}\n\nexport async function buildMintNftTx(\n    mintUtxo: AVMUTXO,\n    payload: PayloadBase,\n    quantity: number,\n    ownerAddress: string,\n    changeAddress: string,\n    fromAddresses: string[],\n    utxoSet: UTXOSet\n): Promise<AVMUnsignedTx> {\n    let addrBuf = bintools.parseAddress(ownerAddress, 'X')\n    let owners = []\n\n    let sourceAddresses = fromAddresses\n\n    for (var i = 0; i < quantity; i++) {\n        let owner = new OutputOwners([addrBuf])\n        owners.push(owner)\n    }\n\n    let groupID = (mintUtxo.getOutput() as NFTMintOutput).getGroupID()\n\n    let mintTx = await avm.buildCreateNFTMintTx(\n        utxoSet,\n        owners,\n        sourceAddresses,\n        [changeAddress],\n        mintUtxo.getUTXOID(),\n        groupID,\n        payload\n    )\n    return mintTx\n}\n\nexport async function buildEvmTransferNativeTx(\n    from: string,\n    to: string,\n    amount: BN, // in wei\n    gasPrice: BN,\n    gasLimit: number\n) {\n    const nonce = await web3.eth.getTransactionCount(from)\n    const chainId = await web3.eth.getChainId()\n    const networkId = await web3.eth.net.getId()\n    const chainParams = {\n        common: EthereumjsCommon.forCustomChain('mainnet', { networkId, chainId }, 'istanbul'),\n    }\n\n    let tx = new Transaction(\n        {\n            nonce: nonce,\n            gasPrice: gasPrice,\n            gasLimit: gasLimit,\n            to: to,\n            value: amount,\n            data: '0x',\n        },\n        chainParams\n    )\n    return tx\n}\n\nexport async function buildEvmTransferErc20Tx(\n    from: string,\n    to: string,\n    amount: BN, // in wei\n    gasPrice: BN,\n    gasLimit: number,\n    token: Erc20Token\n) {\n    const nonce = await web3.eth.getTransactionCount(from)\n    const chainId = await web3.eth.getChainId()\n    const networkId = await web3.eth.net.getId()\n    const chainParams = {\n        common: EthereumjsCommon.forCustomChain('mainnet', { networkId, chainId }, 'istanbul'),\n    }\n\n    let tokenTx = token.createTransferTx(to, amount)\n\n    let tx = new Transaction(\n        {\n            nonce: nonce,\n            gasPrice: gasPrice,\n            gasLimit: gasLimit,\n            value: '0x0',\n            to: token.data.address,\n            data: tokenTx.encodeABI(),\n        },\n        chainParams\n    )\n    return tx\n}\n\nexport async function buildEvmTransferErc721Tx(\n    from: string,\n    to: string,\n    gasPrice: BN,\n    gasLimit: number,\n    token: ERC721Token,\n    tokenId: string\n) {\n    const nonce = await web3.eth.getTransactionCount(from)\n    const chainId = await web3.eth.getChainId()\n    const networkId = await web3.eth.net.getId()\n    const chainParams = {\n        common: EthereumjsCommon.forCustomChain('mainnet', { networkId, chainId }, 'istanbul'),\n    }\n\n    let tokenTx = token.createTransferTx(from, to, tokenId)\n\n    let tx = new Transaction(\n        {\n            nonce: nonce,\n            gasPrice: gasPrice,\n            gasLimit: gasLimit,\n            value: '0x0',\n            to: token.data.address,\n            data: tokenTx.encodeABI(),\n        },\n        chainParams\n    )\n    return tx\n}\n\nexport enum AvmTxNameEnum {\n    'Transaction' = AVMConstants.BASETX,\n    'Mint' = AVMConstants.CREATEASSETTX,\n    'Operation' = AVMConstants.OPERATIONTX,\n    'Import' = AVMConstants.IMPORTTX,\n    'Export' = AVMConstants.EXPORTTX,\n}\n\nexport enum PlatfromTxNameEnum {\n    'Transaction' = PlatformVMConstants.BASETX,\n    'Add Validator' = PlatformVMConstants.ADDVALIDATORTX,\n    'Add Delegator' = PlatformVMConstants.ADDDELEGATORTX,\n    'Import' = PlatformVMConstants.IMPORTTX,\n    'Export' = PlatformVMConstants.EXPORTTX,\n    'Add Subnet Validator' = PlatformVMConstants.ADDSUBNETVALIDATORTX,\n    'Create Chain' = PlatformVMConstants.CREATECHAINTX,\n    'Create Subnet' = PlatformVMConstants.CREATESUBNETTX,\n    'Advance Time' = PlatformVMConstants.ADVANCETIMETX,\n    'Reward Validator' = PlatformVMConstants.REWARDVALIDATORTX,\n}\n\n// TODO: create asset transactions\nexport enum ParseableAvmTxEnum {\n    'Transaction' = AVMConstants.BASETX,\n    'Import' = AVMConstants.IMPORTTX,\n    'Export' = AVMConstants.EXPORTTX,\n}\n\nexport enum ParseablePlatformEnum {\n    'Transaction' = PlatformVMConstants.BASETX,\n    'Add Validator' = PlatformVMConstants.ADDVALIDATORTX,\n    'Add Delegator' = PlatformVMConstants.ADDDELEGATORTX,\n    'Import' = PlatformVMConstants.IMPORTTX,\n    'Export' = PlatformVMConstants.EXPORTTX,\n}\n\nexport enum ParseableEvmTxEnum {\n    'Import' = EVMConstants.IMPORTTX,\n    'Export' = EVMConstants.EXPORTTX,\n}\n","import { Buffer } from 'buffer/'\nimport createHash from 'create-hash'\n\n/**\n * @ignore\n */\n\n/**\n * Helper utility for encryption and password hashing, browser-safe.\n * Encryption is using AES-GCM with a random public nonce.\n */\nexport default class CryptoHelpers {\n    protected ivSize: number = 12\n\n    protected saltSize: number = 16\n\n    protected tagLength: number = 128\n\n    protected aesLength: number = 256\n\n    public keygenIterations: number = 200000 //3.0, 2.0 uses 100000\n\n    /**\n     * Internal-intended function for cleaning passwords.\n     *\n     * @param password\n     * @param salt\n     */\n    _pwcleaner(password: string, slt: Buffer): Buffer {\n        const pw: Buffer = Buffer.from(password, 'utf8')\n        return this.sha256(Buffer.concat([pw, slt]))\n    }\n    /**\n     * Internal-intended function for producing an intermediate key.\n     *\n     * @param pwkey\n     */\n\n    async _keyMaterial(pwkey: Buffer): Promise<CryptoKey> {\n        return window.crypto.subtle.importKey(\n            'raw',\n            new Uint8Array(pwkey),\n            { name: 'PBKDF2' },\n            false,\n            ['deriveKey']\n        )\n    }\n\n    /**\n     * Internal-intended function for turning an intermediate key into a salted key.\n     *\n     * @param keyMaterial\n     * @param salt\n     */\n    async _deriveKey(keyMaterial: CryptoKey, salt: Buffer): Promise<CryptoKey> {\n        return window.crypto.subtle.deriveKey(\n            {\n                name: 'PBKDF2',\n                salt,\n                iterations: this.keygenIterations,\n                hash: 'SHA-256',\n            },\n            keyMaterial,\n            { name: 'AES-GCM', length: this.aesLength },\n            false,\n            ['encrypt', 'decrypt']\n        )\n    }\n\n    /**\n     * A SHA256 helper function.\n     *\n     * @param message The message to hash\n     *\n     * @returns A {@link https://github.com/feross/buffer|Buffer} containing the SHA256 hash of the message\n     */\n    sha256(message: string | Buffer): Buffer {\n        let buff: Buffer\n        if (typeof message === 'string') {\n            buff = Buffer.from(message, 'utf8')\n        } else {\n            buff = Buffer.from(message)\n        }\n        return Buffer.from(createHash('sha256').update(buff).digest()) // ensures correct Buffer class is used\n    }\n\n    /**\n     * Generates a randomized {@link https://github.com/feross/buffer|Buffer} to be used as a salt\n     */\n    makeSalt(): Buffer {\n        const salt = Buffer.alloc(this.saltSize)\n        window.crypto.getRandomValues(salt)\n        return salt\n    }\n\n    /**\n     * Produces a password-safe hash.\n     *\n     * @param password A string for the password\n     * @param salt An optional {@link https://github.com/feross/buffer|Buffer} containing a salt used in the password hash\n     *\n     * @returns An object containing the \"salt\" and the \"hash\" produced by this function, both as {@link https://github.com/feross/buffer|Buffer}.\n     */\n    async pwhash(password: string, salt: Buffer): Promise<{ salt: Buffer; hash: Buffer }> {\n        let slt: Buffer\n        if (salt instanceof Buffer) {\n            slt = salt\n            // @ts-ignore\n        } else if (salt instanceof Uint8Array && process.env.NODE_ENV === 'test') {\n            slt = salt\n        } else {\n            slt = this.makeSalt()\n        }\n\n        const hash: Buffer = this._pwcleaner(password, this._pwcleaner(password, slt))\n        return { salt: slt, hash }\n    }\n\n    /**\n     * Encrypts plaintext with the provided password using AES-GCM.\n     *\n     * @param password A string for the password\n     * @param plaintext The plaintext to encrypt\n     * @param salt An optional {@link https://github.com/feross/buffer|Buffer} for the salt to use in the encryption process\n     *\n     * @returns An object containing the \"salt\", \"iv\", and \"ciphertext\", all as {@link https://github.com/feross/buffer|Buffer}.\n     */\n    async encrypt(\n        password: string,\n        plaintext: Buffer | string,\n        salt: Buffer | undefined = undefined\n    ): Promise<{ salt: Buffer; iv: Buffer; ciphertext: Buffer }> {\n        let slt: Buffer\n        if (typeof salt !== 'undefined' && salt instanceof Buffer) {\n            slt = salt\n        } else {\n            slt = this.makeSalt()\n        }\n\n        let pt: Buffer\n        if (typeof plaintext !== 'undefined' && plaintext instanceof Buffer) {\n            pt = plaintext\n        } else {\n            pt = Buffer.from(plaintext, 'utf8')\n        }\n        const pwkey: Buffer = this._pwcleaner(password, slt)\n        const keyMaterial: CryptoKey = await this._keyMaterial(pwkey)\n        const pkey: CryptoKey = await this._deriveKey(keyMaterial, slt)\n        const iv: Buffer = Buffer.from(window.crypto.getRandomValues(new Uint8Array(this.ivSize)))\n\n        const ciphertext: Buffer = Buffer.from(\n            await window.crypto.subtle.encrypt(\n                {\n                    name: 'AES-GCM',\n                    iv,\n                    additionalData: slt,\n                    tagLength: this.tagLength,\n                },\n                pkey,\n                pt\n            )\n        )\n\n        return {\n            salt: slt,\n            iv,\n            ciphertext,\n        }\n    }\n\n    /**\n     * Decrypts ciphertext with the provided password, iv, and salt.\n     *\n     * @param password A string for the password\n     * @param ciphertext A {@link https://github.com/feross/buffer|Buffer} for the ciphertext\n     * @param salt A {@link https://github.com/feross/buffer|Buffer} for the salt\n     * @param iv A {@link https://github.com/feross/buffer|Buffer} for the iv\n     */\n    async decrypt(password: string, ciphertext: Buffer, salt: Buffer, iv: Buffer): Promise<Buffer> {\n        const pwkey: Buffer = this._pwcleaner(password, salt)\n        const keyMaterial: CryptoKey = await this._keyMaterial(pwkey)\n        const pkey: CryptoKey = await this._deriveKey(keyMaterial, salt)\n\n        const pt: Buffer = Buffer.from(\n            await window.crypto.subtle.decrypt(\n                {\n                    name: 'AES-GCM',\n                    iv, // The initialization vector you used to encrypt\n                    additionalData: salt, // The addtionalData you used to encrypt (if any)\n                    tagLength: 128, // The tagLength you used to encrypt (if any)\n                },\n                pkey, // from generateKey or importKey above\n                ciphertext // ArrayBuffer of the data\n            )\n        )\n        return pt\n    }\n\n    constructor() {}\n}\n","// Functions to manage import/export of keystore files\nimport {\n    AllKeyFileDecryptedTypes,\n    AllKeyFileTypes,\n    KeyFileDecryptedV2,\n    KeyFileDecryptedV3,\n    KeyFileDecryptedV4,\n    KeyFileDecryptedV5,\n    KeyFileDecryptedV6,\n    KeyFileKeyDecryptedV2,\n    KeyFileKeyDecryptedV3,\n    KeyFileKeyDecryptedV4,\n    KeyFileKeyDecryptedV5,\n    KeyFileKeyDecryptedV6,\n    KeyFileKeyV2,\n    KeyFileKeyV3,\n    KeyFileKeyV4,\n    KeyFileKeyV5,\n    KeyFileKeyV6,\n    KeyFileV2,\n    KeyFileV3,\n    KeyFileV4,\n    KeyFileV5,\n    KeyFileV6,\n    KeystoreFileKeyType,\n} from './IKeystore'\nimport { avm, bintools } from '@/AVA'\nimport { Buffer } from 'buffer/'\nimport MnemonicWallet from '@/js/wallets/MnemonicWallet'\nimport Crypto from '@/js/Crypto'\nimport { SingletonWallet } from '@/js/wallets/SingletonWallet'\nimport { AccessWalletMultipleInput } from '@/store/types'\nimport { keyToKeypair } from '@/helpers/helper'\nimport * as bip39 from 'bip39'\nimport { Buffer as AjsBuffer } from 'avalanche'\n\nconst cryptoHelpers = new Crypto()\n\nconst KEYSTORE_VERSION: string = '6.0'\n\nconst ITERATIONS_V2 = 100000\nconst ITERATIONS_V3 = 200000 // and any version above\n\nconst SUPPORTED_VERSION = ['2.0', '3.0', '4.0', '5.0', '6.0']\n\ninterface IHash {\n    salt: Buffer\n    hash: Buffer\n}\n\ninterface PKCrypt {\n    salt: Buffer\n    iv: Buffer\n    ciphertext: Buffer\n}\n\nasync function readV2(data: KeyFileV2, pass: string) {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V2\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n    let pass_hash: string = data.pass_hash\n\n    let checkHashString: string\n    let checkHash: Buffer = await cryptoHelpers._pwcleaner(pass, salt)\n    checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash))\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    let keys: KeyFileKeyV2[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV2[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV2 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        let key_string = bintools.cb58Encode(AjsBuffer.from(key_decrypt))\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\nasync function readV3(data: KeyFileV3, pass: string) {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n    let pass_hash: string = data.pass_hash\n\n    let checkHashString: string\n    let checkHash: IHash = await cryptoHelpers.pwhash(pass, salt)\n    checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash.hash))\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    let keys: KeyFileKeyV3[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV3[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV3 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        let key_string = bintools.cb58Encode(AjsBuffer.from(key_decrypt))\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\nasync function readV4(data: KeyFileV4, pass: string): Promise<KeyFileDecryptedV5> {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n    let pass_hash: string = data.pass_hash\n\n    let checkHashString: string\n    let checkHash: IHash = await cryptoHelpers.pwhash(pass, salt)\n    checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash.hash))\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    let keys: KeyFileKeyV4[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV4[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV4 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        let key_string = bintools.cb58Encode(AjsBuffer.from(key_decrypt))\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\n\nasync function readV5(data: KeyFileV5, pass: string): Promise<KeyFileDecryptedV5> {\n    const version: string = data.version\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n    let pass_hash = data.pass_hash\n\n    let checkHashString: string\n    let checkHash: IHash = await cryptoHelpers.pwhash(pass, salt)\n    checkHashString = bintools.cb58Encode(AjsBuffer.from(checkHash.hash))\n\n    if (checkHashString !== pass_hash) {\n        throw 'INVALID_PASS'\n    }\n\n    let keys: KeyFileKeyV5[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV5[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV5 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        let key_string = key_decrypt.toString()\n\n        keysDecrypt.push({\n            key: key_string,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: 0,\n        keys: keysDecrypt,\n    }\n}\n\nasync function readV6(data: KeyFileV6, pass: string): Promise<KeyFileDecryptedV6> {\n    const version: string = data.version\n    const activeIndex = data.activeIndex\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = bintools.cb58Decode(data.salt)\n\n    let keys: KeyFileKeyV6[] = data.keys\n    let keysDecrypt: KeyFileKeyDecryptedV6[] = []\n\n    for (let i: number = 0; i < keys.length; i++) {\n        let key_data: KeyFileKeyV6 = keys[i]\n\n        let key: Buffer = bintools.cb58Decode(key_data.key)\n        let type: KeystoreFileKeyType = key_data.type\n        let nonce: Buffer = bintools.cb58Decode(key_data.iv)\n\n        let key_decrypt: Buffer\n        try {\n            key_decrypt = await cryptoHelpers.decrypt(pass, key, salt, nonce)\n        } catch (e) {\n            throw 'INVALID_PASS'\n        }\n\n        const key_string = key_decrypt.toString()\n\n        keysDecrypt.push({\n            key: key_string,\n            type: type,\n        })\n    }\n\n    return {\n        version,\n        activeIndex: activeIndex || 0,\n        keys: keysDecrypt,\n    }\n}\n\nasync function readKeyFile(data: AllKeyFileTypes, pass: string): Promise<AllKeyFileDecryptedTypes> {\n    switch (data.version) {\n        case '6.0':\n            return await readV6(data as KeyFileV6, pass)\n        case '5.0':\n            return await readV5(data as KeyFileV5, pass)\n        case '4.0':\n            return await readV4(data as KeyFileV4, pass)\n        case '3.0':\n            return await readV3(data as KeyFileV3, pass)\n        case '2.0':\n            return await readV2(data as KeyFileV2, pass)\n        default:\n            throw 'INVALID_VERSION'\n    }\n}\n\nfunction extractKeysV2(\n    file: KeyFileDecryptedV2 | KeyFileDecryptedV3 | KeyFileDecryptedV4\n): AccessWalletMultipleInput[] {\n    let chainID = avm.getBlockchainAlias()\n    let keys = (file as KeyFileDecryptedV2 | KeyFileDecryptedV3 | KeyFileDecryptedV4).keys\n\n    return keys.map((key) => {\n        // Private keys from the keystore file do not have the PrivateKey- prefix\n        let pk = 'PrivateKey-' + key.key\n        let keypair = keyToKeypair(pk, chainID)\n\n        let keyBuf = keypair.getPrivateKey()\n        let keyHex: string = keyBuf.toString('hex')\n        let paddedKeyHex = keyHex.padStart(64, '0')\n        let mnemonic: string = bip39.entropyToMnemonic(paddedKeyHex)\n\n        return {\n            key: mnemonic,\n            type: 'mnemonic',\n        }\n    })\n}\n\nfunction extractKeysV5(file: KeyFileDecryptedV5): AccessWalletMultipleInput[] {\n    return file.keys.map((key) => ({\n        key: key.key,\n        type: 'mnemonic',\n    }))\n}\n\nfunction extractKeysV6(file: KeyFileDecryptedV6): AccessWalletMultipleInput[] {\n    return file.keys.map((key) => ({\n        type: key.type,\n        key: key.key,\n    }))\n}\n\nfunction extractKeysFromDecryptedFile(file: AllKeyFileDecryptedTypes): AccessWalletMultipleInput[] {\n    switch (file.version) {\n        case '6.0':\n            return extractKeysV6(file as KeyFileDecryptedV6)\n        case '5.0':\n            return extractKeysV5(file as KeyFileDecryptedV5)\n        case '4.0':\n            return extractKeysV2(file as KeyFileDecryptedV4)\n        case '3.0':\n            return extractKeysV2(file as KeyFileDecryptedV3)\n        case '2.0':\n            return extractKeysV2(file as KeyFileDecryptedV2)\n        default:\n            throw 'INVALID_VERSION'\n    }\n}\n\n// Given an array of wallets and a password, return an encrypted JSON object that is the keystore file\nasync function makeKeyfile(\n    wallets: (MnemonicWallet | SingletonWallet)[],\n    pass: string,\n    activeIndex: number\n): Promise<KeyFileV6> {\n    // 3.0 and above uses 200,000\n    cryptoHelpers.keygenIterations = ITERATIONS_V3\n\n    let salt: Buffer = await cryptoHelpers.makeSalt()\n\n    let keys: KeyFileKeyV6[] = []\n\n    for (let i: number = 0; i < wallets.length; i++) {\n        let wallet = wallets[i]\n        let key\n        let type: KeystoreFileKeyType\n        if (wallet.type === 'singleton') {\n            key = (wallet as SingletonWallet).key\n            type = 'singleton'\n        } else {\n            key = (wallet as MnemonicWallet).getMnemonic()\n            type = 'mnemonic'\n        }\n        let pk_crypt: PKCrypt = await cryptoHelpers.encrypt(pass, key, salt)\n\n        let key_data: KeyFileKeyV6 = {\n            key: bintools.cb58Encode(AjsBuffer.from(pk_crypt.ciphertext)),\n            iv: bintools.cb58Encode(AjsBuffer.from(pk_crypt.iv)),\n            type: type,\n        }\n        keys.push(key_data)\n    }\n\n    let file_data: KeyFileV6 = {\n        version: KEYSTORE_VERSION,\n        salt: bintools.cb58Encode(AjsBuffer.from(salt)),\n        activeIndex,\n        keys: keys,\n    }\n    return file_data\n}\n\nexport { readKeyFile, makeKeyfile, KEYSTORE_VERSION, extractKeysFromDecryptedFile }\n","import axios, { AxiosInstance } from 'axios'\nimport { ITransactionData } from './store/modules/history/types'\n\n// Doesn't really matter what we set, it will change\nconst api_url: string = 'localhost'\nconst explorer_api: AxiosInstance = axios.create({\n    baseURL: api_url,\n    withCredentials: false,\n    headers: {\n        'Content-Type': 'application/json',\n    },\n})\n\nasync function getAddressHistory(\n    addrs: string[],\n    limit = 20,\n    chainID: string,\n    endTime?: string\n): Promise<ITransactionData[]> {\n    const ADDR_SIZE = 1024\n    let selection = addrs.slice(0, ADDR_SIZE)\n    let remaining = addrs.slice(ADDR_SIZE)\n\n    let addrsRaw = selection.map((addr) => {\n        return addr.split('-')[1]\n    })\n\n    let rootUrl = 'v2/transactions'\n\n    let req = {\n        address: addrsRaw,\n        sort: ['timestamp-desc'],\n        disableCount: ['1'],\n        chainID: [chainID],\n        disableGenesis: ['false'],\n    }\n\n    if (limit > 0) {\n        //@ts-ignore\n        req.limit = [limit.toString()]\n    }\n\n    if (endTime) {\n        console.log('Setting endtime')\n        //@ts-ignore\n        req.endTime = [endTime]\n    }\n\n    let res = await explorer_api.post(rootUrl, req)\n    let txs = res.data.transactions\n    let next: string | undefined = res.data.next\n\n    if (txs === null) txs = []\n\n    // If we need to fetch more for this address\n    if (next && !limit) {\n        let endTime = next.split('&')[0].split('=')[1]\n        let nextRes = await getAddressHistory(selection, limit, chainID, endTime)\n        txs.push(...nextRes)\n    }\n\n    // If there are addresses left, fetch them too\n    if (remaining.length > 0) {\n        let nextRes = await getAddressHistory(remaining, limit, chainID)\n        txs.push(...nextRes)\n    }\n\n    return txs\n}\n\nasync function isAddressUsedX(addr: string) {\n    let addrRaw = addr.split('-')[1]\n    let url = `/x/transactions?address=${addrRaw}&limit=1&disableCount=1`\n    try {\n        let res = await explorer_api.get(url)\n        // console.log(res);\n        if (res.data.transactions.length > 0) return true\n        else return false\n    } catch (e) {\n        throw e\n    }\n}\n\nasync function getAddressDetailX(addr: string) {\n    let addrRaw = addr.split('-')[1]\n    let url = `/x/addresses/${addrRaw}`\n\n    try {\n        let res = await explorer_api.get(url)\n        return res.data\n    } catch (e) {\n        throw e\n    }\n}\n\nasync function getAddressChains(addrs: string[]) {\n    // Strip the prefix\n    let rawAddrs = addrs.map((addr) => {\n        return addr.split('-')[1]\n    })\n\n    let urlRoot = `/v2/addressChains`\n\n    let res = await explorer_api.post(urlRoot, {\n        address: rawAddrs,\n        disableCount: ['1'],\n    })\n\n    return res.data.addressChains\n}\n\nexport { explorer_api, getAddressHistory, getAddressDetailX, isAddressUsedX, getAddressChains }\n","import Web3 from 'web3'\n\nimport ERC721Abi from '@openzeppelin/contracts/build/contracts/ERC721.json'\nimport ERC20Abi from '@openzeppelin/contracts/build/contracts/ERC20.json'\n\nconst abiDecoder = require('abi-decoder') // NodeJS\n\nabiDecoder.addABI(ERC721Abi.abi)\nabiDecoder.addABI(ERC20Abi.abi)\n\nlet rpcUrl = `https://api.avax.network/ext/bc/C/rpc`\n\nlet web3 = new Web3(rpcUrl)\n\nexport { web3, abiDecoder }\n","const axios = require('axios')\n\nconst COIN_ID = 'avalanche-2'\nconst COINGECKO_URL =\n    'https://api.coingecko.com/api/v3/simple/price?ids=avalanche-2&vs_currencies=usd'\n\nconst coingeckoApi = axios.create({\n    baseURL: 'https://api.coingecko.com/api/v3',\n    timeout: 10000,\n})\n\nexport async function getAvaxPriceUSD(): Promise<number> {\n    let res = await axios.get(COINGECKO_URL)\n    return res.data['avalanche-2']['usd']\n}\n\nlet priceHistory: [number, number][] = []\nasync function getPriceHistory() {\n    let res = await coingeckoApi.get(`/coins/${COIN_ID}/market_chart`, {\n        params: {\n            vs_currency: 'usd',\n            days: 'max',\n            interval: 'daily',\n        },\n    })\n\n    priceHistory = res.data.prices\n}\n\n/**\n * Round the UNIX time in ms and search the previously fetched price points\n * @param time\n */\nexport function getPriceAtUnixTime(time: number): number | undefined {\n    let remainder = time % (24 * 60 * 60 * 1000)\n    let dayTimestamp = time - remainder\n\n    let pricePair = priceHistory.find((value) => {\n        return value[0] == dayTimestamp\n    })\n\n    if (!pricePair) return undefined\n    return pricePair[1]\n}\n\ngetPriceHistory()\n","import {\n    KeyChain as AVMKeyChain,\n    KeyPair as AVMKeyPair,\n    UTXOSet as AVMUTXOSet,\n} from 'avalanche/dist/apis/avm'\n\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm'\nimport { getPreferredHRP } from 'avalanche/dist/utils'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport HDKey from 'hdkey'\nimport { Buffer } from 'avalanche'\nimport {\n    KeyChain as PlatformVMKeyChain,\n    KeyPair as PlatformVMKeyPair,\n} from 'avalanche/dist/apis/platformvm'\nimport store from '@/store'\n\nimport { getAddressChains } from '@/explorer_api'\nimport { AvaNetwork } from '@/js/AvaNetwork'\nimport { ChainAlias } from './wallets/types'\nimport { avmGetAllUTXOs, platformGetAllUTXOs } from '@/helpers/utxo_helper'\nimport { updateFilterAddresses } from '../providers'\n\nconst INDEX_RANGE: number = 20 // a gap of at least 20 indexes is needed to claim an index unused\n\nconst SCAN_SIZE: number = 100 // the total number of utxos to look at initially to calculate last index\nconst SCAN_RANGE: number = SCAN_SIZE - INDEX_RANGE // How many items are actually scanned\nclass HdHelper {\n    chainId: ChainAlias\n    keyChain: AVMKeyChain | PlatformVMKeyChain\n    keyCache: {\n        [index: number]: AVMKeyPair | PlatformVMKeyPair\n    }\n    addressCache: {\n        [index: number]: string\n    }\n    hdCache: {\n        [index: number]: HDKey\n    }\n    changePath: string\n    masterKey: HDKey\n    hdIndex: number\n    utxoSet: AVMUTXOSet | PlatformUTXOSet\n    isPublic: boolean\n    isFetchUtxo: boolean // true if updating balance\n    isInit: boolean // true if HD index is found\n\n    constructor(\n        changePath: string,\n        masterKey: HDKey,\n        chainId: ChainAlias = 'X',\n        isPublic: boolean = false\n    ) {\n        this.changePath = changePath\n        this.isFetchUtxo = false\n        this.isInit = false\n\n        this.chainId = chainId\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        if (chainId === 'X') {\n            this.keyChain = new AVMKeyChain(hrp, chainId)\n            this.utxoSet = new AVMUTXOSet()\n        } else {\n            this.keyChain = new PlatformVMKeyChain(hrp, chainId)\n            this.utxoSet = new PlatformUTXOSet()\n        }\n\n        this.keyCache = {}\n        this.addressCache = {}\n        this.hdCache = {}\n        this.masterKey = masterKey\n        this.hdIndex = 0\n        this.isPublic = isPublic\n        // this.oninit()\n    }\n\n    async oninit() {\n        await this.findHdIndex()\n    }\n\n    // When the wallet connects to a different network\n    // Clear internal data and scan again\n    async onNetworkChange() {\n        this.clearCache()\n        this.isInit = false\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        if (this.chainId === 'X') {\n            this.keyChain = new AVMKeyChain(hrp, this.chainId)\n            this.utxoSet = new AVMUTXOSet()\n        } else {\n            this.keyChain = new PlatformVMKeyChain(hrp, this.chainId)\n            this.utxoSet = new PlatformUTXOSet()\n        }\n        this.hdIndex = 0\n        await this.oninit()\n    }\n\n    // Increments the hd index by one and adds the key\n    // returns the new keypair\n    incrementIndex(): number {\n        let newIndex: number = this.hdIndex + 1\n\n        if (!this.isPublic) {\n            if (this.chainId === 'X') {\n                let keychain = this.keyChain as AVMKeyChain\n                let newKey = this.getKeyForIndex(newIndex) as AVMKeyPair\n                keychain.addKey(newKey)\n            } else {\n                let keychain = this.keyChain as PlatformVMKeyChain\n                let newKey = this.getKeyForIndex(newIndex) as PlatformVMKeyPair\n                keychain.addKey(newKey)\n            }\n        }\n\n        this.hdIndex = newIndex\n\n        // Update websocket addresses with the new one\n        updateFilterAddresses()\n\n        return newIndex\n    }\n\n    async findHdIndex() {\n        // Check if explorer is available\n\n        // @ts-ignore\n        let network: AvaNetwork = store.state.Network.selectedNetwork\n        let explorerUrl = network.explorerUrl\n\n        if (explorerUrl) {\n            this.hdIndex = await this.findAvailableIndexExplorer()\n        } else {\n            this.hdIndex = await this.findAvailableIndexNode()\n        }\n\n        if (!this.isPublic) {\n            this.updateKeychain()\n        }\n        this.isInit = true\n    }\n\n    // Fetches the utxos for the current keychain\n    // and increments the index if last index has a utxo\n    async updateUtxos(): Promise<AVMUTXOSet | PlatformUTXOSet> {\n        this.isFetchUtxo = true\n\n        if (!this.isInit) {\n            console.error('HD Index not found yet.')\n        }\n\n        let addrs: string[] = this.getAllDerivedAddresses()\n        let result: AVMUTXOSet | PlatformUTXOSet\n\n        if (this.chainId === 'X') {\n            result = await avmGetAllUTXOs(addrs)\n        } else {\n            result = await platformGetAllUTXOs(addrs)\n        }\n        this.utxoSet = result // we can use local copy of utxos as cache for some functions\n\n        // If the hd index is full, increment\n        let currentAddr = this.getCurrentAddress()\n        let currentAddrBuf = bintools.parseAddress(currentAddr, this.chainId)\n        let currentUtxos = result.getUTXOIDs([currentAddrBuf])\n\n        if (currentUtxos.length > 0) {\n            this.incrementIndex()\n        }\n        this.isFetchUtxo = false\n        return result\n    }\n\n    // Returns more addresses than the current index\n    getExtendedAddresses() {\n        let hdIndex = this.hdIndex\n        return this.getAllDerivedAddresses(hdIndex + INDEX_RANGE)\n    }\n\n    // Not used?\n    getUtxos(): AVMUTXOSet | PlatformUTXOSet {\n        return this.utxoSet\n    }\n\n    // Updates the helper keychain to contain keys upto the HD Index\n    updateKeychain(): AVMKeyChain | PlatformVMKeyChain {\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        let keychain: AVMKeyChain | PlatformVMKeyChain\n\n        if (this.chainId === 'X') {\n            keychain = new AVMKeyChain(hrp, this.chainId)\n        } else {\n            keychain = new PlatformVMKeyChain(hrp, this.chainId)\n        }\n\n        for (let i: number = 0; i <= this.hdIndex; i++) {\n            let key: AVMKeyPair | PlatformVMKeyPair\n            if (this.chainId === 'X') {\n                key = this.getKeyForIndex(i) as AVMKeyPair\n                ;(keychain as AVMKeyChain).addKey(key)\n            } else {\n                key = this.getKeyForIndex(i) as PlatformVMKeyPair\n                ;(keychain as PlatformVMKeyChain).addKey(key)\n            }\n        }\n        this.keyChain = keychain\n        return keychain\n    }\n\n    getKeychain() {\n        return this.keyChain\n    }\n\n    // Returns all key pairs up to hd index\n    getAllDerivedKeys(upTo = this.hdIndex): AVMKeyPair[] | PlatformVMKeyPair[] {\n        let set: AVMKeyPair[] | PlatformVMKeyPair[] = []\n        for (var i = 0; i <= upTo; i++) {\n            if (this.chainId === 'X') {\n                let key = this.getKeyForIndex(i) as AVMKeyPair\n                ;(set as AVMKeyPair[]).push(key)\n            } else {\n                let key = this.getKeyForIndex(i) as PlatformVMKeyPair\n                ;(set as PlatformVMKeyPair[]).push(key)\n            }\n        }\n        return set\n    }\n\n    getAllDerivedAddresses(upTo = this.hdIndex, start = 0): string[] {\n        let res = []\n        for (var i = start; i <= upTo; i++) {\n            let addr = this.getAddressForIndex(i)\n            res.push(addr)\n        }\n        return res\n    }\n\n    clearCache() {\n        this.keyCache = {}\n        this.addressCache = {}\n    }\n\n    // Scans the address space of this hd path and finds the last used index using the\n    // explorer API.\n    async findAvailableIndexExplorer(startIndex = 0): Promise<number> {\n        let upTo = 512\n\n        let addrs = this.getAllDerivedAddresses(startIndex + upTo, startIndex)\n        let addrChains = await getAddressChains(addrs)\n\n        let chainID\n        if (this.chainId === 'X') {\n            chainID = avm.getBlockchainID()\n        } else {\n            chainID = pChain.getBlockchainID()\n        }\n\n        for (var i = 0; i < addrs.length - INDEX_RANGE; i++) {\n            let gapSize: number = 0\n\n            for (var n = 0; n < INDEX_RANGE; n++) {\n                let scanIndex = i + n\n                let scanAddr = addrs[scanIndex]\n\n                let rawAddr = scanAddr.split('-')[1]\n                let chains: string[] = addrChains[rawAddr]\n                if (!chains) {\n                    // If doesnt exist on any chain\n                    gapSize++\n                } else if (!chains.includes(chainID)) {\n                    // If doesnt exist on this chain\n                    gapSize++\n                } else {\n                    i = i + n\n                    break\n                }\n            }\n\n            // If the gap is reached return the index\n            if (gapSize === INDEX_RANGE) {\n                return startIndex + i\n            }\n        }\n\n        return await this.findAvailableIndexExplorer(startIndex + (upTo - INDEX_RANGE))\n    }\n\n    // Uses the node to find last used HD index\n    // Only used when there is no explorer API available\n    async findAvailableIndexNode(start: number = 0): Promise<number> {\n        let addrs: string[] = []\n\n        // Get keys for indexes start to start+scan_size\n        for (let i: number = start; i < start + SCAN_SIZE; i++) {\n            let address = this.getAddressForIndex(i)\n            addrs.push(address)\n        }\n\n        let utxoSet\n\n        if (this.chainId === 'X') {\n            utxoSet = (await avm.getUTXOs(addrs)).utxos\n        } else {\n            utxoSet = (await pChain.getUTXOs(addrs)).utxos\n        }\n\n        // Scan UTXOs of these indexes and try to find a gap of INDEX_RANGE\n        for (let i: number = 0; i < addrs.length - INDEX_RANGE; i++) {\n            let gapSize: number = 0\n            // console.log(`Scan index: ${this.chainId} ${this.changePath}/${i+start}`);\n            for (let n: number = 0; n < INDEX_RANGE; n++) {\n                let scanIndex: number = i + n\n                let addr: string = addrs[scanIndex]\n                let addrBuf = bintools.parseAddress(addr, this.chainId)\n                let addrUTXOs: string[] = utxoSet.getUTXOIDs([addrBuf])\n                if (addrUTXOs.length === 0) {\n                    gapSize++\n                } else {\n                    // Potential improvement\n                    i = i + n\n                    break\n                }\n            }\n\n            // If we found a gap of 20, we can return the last fullIndex+1\n            if (gapSize === INDEX_RANGE) {\n                let targetIndex = start + i\n                return targetIndex\n            }\n        }\n        return await this.findAvailableIndexNode(start + SCAN_RANGE)\n    }\n\n    getFirstAvailableIndex(): number {\n        for (var i = 0; i < this.hdIndex; i++) {\n            let addr = this.getAddressForIndex(i)\n            let addrBuf = bintools.parseAddress(addr, this.chainId)\n            let utxoIds = this.utxoSet.getUTXOIDs([addrBuf])\n            if (utxoIds.length === 0) {\n                return i\n            }\n        }\n\n        return 0\n    }\n\n    // Returns the key of the first index that has no utxos\n    getFirstAvailableAddress(): string {\n        const idx = this.getFirstAvailableIndex()\n        return this.getAddressForIndex(idx)\n    }\n\n    getCurrentKey(): AVMKeyPair | PlatformVMKeyPair {\n        let index: number = this.hdIndex\n        return this.getKeyForIndex(index)\n    }\n\n    getCurrentAddress(): string {\n        let index = this.hdIndex\n        return this.getAddressForIndex(index)\n    }\n\n    // TODO: Public wallet should never be using this\n    getKeyForIndex(index: number, isPrivate: boolean = true): AVMKeyPair | PlatformVMKeyPair {\n        // If key is cached return that\n        let cacheExternal: AVMKeyPair | PlatformVMKeyPair\n\n        if (this.chainId === 'X') {\n            cacheExternal = this.keyCache[index] as AVMKeyPair\n        } else {\n            cacheExternal = this.keyCache[index] as PlatformVMKeyPair\n        }\n\n        if (cacheExternal) return cacheExternal\n\n        let derivationPath: string = `${this.changePath}/${index.toString()}`\n\n        // Get key from cache, if not generate it\n        let key: HDKey\n        if (this.hdCache[index]) {\n            key = this.hdCache[index]\n        } else {\n            key = this.masterKey.derive(derivationPath) as HDKey\n            this.hdCache[index] = key\n        }\n\n        let pkHex: string\n        if (!this.isPublic) {\n            pkHex = key.privateKey.toString('hex')\n        } else {\n            pkHex = key.publicKey.toString('hex')\n        }\n\n        let pkBuf: Buffer = new Buffer(pkHex, 'hex')\n        let keypair = this.keyChain.importKey(pkBuf)\n\n        // save to cache\n        this.keyCache[index] = keypair\n        return keypair\n    }\n\n    getAddressForIndex(index: number): string {\n        if (this.addressCache[index]) {\n            return this.addressCache[index]\n        }\n\n        let derivationPath: string = `${this.changePath}/${index.toString()}`\n        // let key: HDKey = this.masterKey.derive(derivationPath) as HDKey;\n\n        // Get key from cache, if not generate it\n        let key: HDKey\n        if (this.hdCache[index]) {\n            key = this.hdCache[index]\n        } else {\n            key = this.masterKey.derive(derivationPath) as HDKey\n            this.hdCache[index] = key\n        }\n\n        let pkHex = key.publicKey.toString('hex')\n        let pkBuff = Buffer.from(pkHex, 'hex')\n        let hrp = getPreferredHRP(ava.getNetworkID())\n\n        let chainId = this.chainId\n\n        // No need for PlatformKeypair because addressToString uses chainID to decode\n        let keypair = new AVMKeyPair(hrp, chainId)\n        let addrBuf = keypair.addressFromPublicKey(pkBuff)\n        let addr = bintools.addressToString(hrp, chainId, addrBuf)\n\n        this.addressCache[index] = addr\n        return addr\n    }\n\n    // Given an address find the derived index\n    findAddressIndex(addr: string): number | null {\n        let addrs = this.getAllDerivedAddresses()\n        let index = addrs.indexOf(addr)\n\n        if (index < 0) return null\n        return index\n    }\n}\nexport { HdHelper }\n","import { ChainAlias } from '@/js/wallets/types'\nimport { UTXO } from 'avalanche/dist/apis/avm'\n\nimport { BN, Buffer } from 'avalanche'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { ava, avm, bintools, pChain } from '@/AVA'\nimport { UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm/utxos'\nimport HDKey from 'hdkey'\nimport { HdHelper } from '@/js/HdHelper'\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm/utxos'\nimport { buildCreateNftFamilyTx, buildMintNftTx, buildUnsignedTransaction } from '../TxHelper'\nimport { WalletCore } from '@/js/wallets/WalletCore'\nimport { updateFilterAddresses } from '../../providers'\nimport { digestMessage } from '@/helpers/helper'\n\n// A base class other HD wallets are based on.\n// Mnemonic Wallet and LedgerWallet uses this\n\nabstract class HdWalletCore extends WalletCore {\n    chainId: string\n\n    internalHelper: HdHelper\n    externalHelper: HdHelper\n    platformHelper: HdHelper\n\n    ethHdNode: HDKey\n\n    constructor(accountHdKey: HDKey, ethHdNode: HDKey, isPublic = true) {\n        super()\n        this.ethHdNode = ethHdNode\n        this.chainId = avm.getBlockchainAlias() || avm.getBlockchainID()\n        this.externalHelper = new HdHelper('m/0', accountHdKey, undefined, isPublic)\n        this.internalHelper = new HdHelper('m/1', accountHdKey, undefined, isPublic)\n        this.platformHelper = new HdHelper('m/0', accountHdKey, 'P', isPublic)\n\n        this.externalHelper.oninit().then((res) => {\n            this.updateInitState()\n        })\n        this.internalHelper.oninit().then((res) => {\n            this.updateInitState()\n        })\n        this.platformHelper.oninit().then((res) => {\n            this.updateInitState()\n        })\n    }\n\n    getEvmAddressBech(): string {\n        return bintools.addressToString(\n            ava.getHRP(),\n            'C',\n            // @ts-ignore\n            this.ethHdNode.pubKeyHash\n        )\n    }\n\n    updateAvmUTXOSet(): void {\n        // if (this.isFetchUtxos) return\n        let setExternal = this.externalHelper.utxoSet as AVMUTXOSet\n        let setInternal = this.internalHelper.utxoSet as AVMUTXOSet\n\n        let joined = setInternal.merge(setExternal)\n        this.utxoset = joined\n    }\n\n    getFirstAvailableAddressPlatform(): string {\n        return this.platformHelper.getFirstAvailableAddress()\n    }\n\n    updateFetchState() {\n        this.isFetchUtxos =\n            this.externalHelper.isFetchUtxo ||\n            this.internalHelper.isFetchUtxo ||\n            this.platformHelper.isFetchUtxo\n    }\n\n    updateInitState() {\n        this.isInit =\n            this.externalHelper.isInit && this.internalHelper.isInit && this.platformHelper.isInit\n\n        if (this.isInit) {\n            updateFilterAddresses()\n        }\n    }\n    // Fetches the utxos\n    async getUTXOs(): Promise<void> {\n        this.updateUTXOsX()\n\n        // platform utxos are updated but not returned by function\n        this.updateUTXOsP()\n\n        return\n    }\n\n    async updateUTXOsX() {\n        this.updateUTXOsExternal()\n        this.updateUTXOsInternal()\n    }\n\n    async updateUTXOsExternal() {\n        let res = await this.externalHelper.updateUtxos()\n        this.updateFetchState()\n        this.updateAvmUTXOSet()\n    }\n\n    async updateUTXOsInternal() {\n        let utxoSet = await this.internalHelper.updateUtxos()\n        this.updateFetchState()\n        this.updateAvmUTXOSet()\n    }\n\n    async updateUTXOsP() {\n        let utxoSet = await this.platformHelper.updateUtxos()\n        this.updateFetchState()\n    }\n\n    getAllDerivedExternalAddresses(): string[] {\n        return this.externalHelper.getAllDerivedAddresses()\n    }\n\n    getDerivedAddresses(): string[] {\n        let internal = this.internalHelper.getAllDerivedAddresses()\n        let external = this.externalHelper.getAllDerivedAddresses()\n        return internal.concat(external)\n    }\n\n    getDerivedAddressesP(): string[] {\n        return this.platformHelper.getAllDerivedAddresses()\n    }\n\n    getAllAddressesX() {\n        return this.getDerivedAddresses()\n    }\n\n    getAllAddressesP() {\n        return this.getDerivedAddressesP()\n    }\n    // Returns addresses to check for history\n    getHistoryAddresses(): string[] {\n        let internalIndex = this.internalHelper.hdIndex\n        // They share the same address space, so whatever has the highest index\n        let externalIndex = Math.max(this.externalHelper.hdIndex, this.platformHelper.hdIndex)\n\n        let internal = this.internalHelper.getAllDerivedAddresses(internalIndex)\n        let external = this.externalHelper.getAllDerivedAddresses(externalIndex)\n        return internal.concat(external)\n    }\n\n    getCurrentAddressAvm(): string {\n        return this.externalHelper.getCurrentAddress()\n    }\n\n    getChangeAddressAvm() {\n        return this.internalHelper.getCurrentAddress()\n    }\n\n    getChangeAddressPlatform() {\n        return this.platformHelper.getCurrentAddress()\n    }\n\n    getChangePath(chainId?: ChainAlias): string {\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.changePath\n            case 'X':\n            default:\n                return this.internalHelper.changePath\n        }\n    }\n\n    getChangeIndex(chainId?: ChainAlias): number {\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.hdIndex\n            case 'X':\n            default:\n                return this.internalHelper.hdIndex\n        }\n    }\n\n    getChangeFromIndex(idx?: number, chainId?: ChainAlias): string | null {\n        if (idx === undefined || idx === null) return null\n\n        switch (chainId) {\n            case 'P':\n                return this.platformHelper.getAddressForIndex(idx)\n            case 'X':\n            default:\n                return this.internalHelper.getAddressForIndex(idx)\n        }\n    }\n\n    getPlatformRewardAddress(): string {\n        return this.platformHelper.getCurrentAddress()\n    }\n\n    getCurrentAddressPlatform(): string {\n        return this.platformHelper.getCurrentAddress()\n    }\n\n    getPlatformUTXOSet() {\n        return this.platformHelper.utxoSet as PlatformUTXOSet\n    }\n\n    getPlatformActiveIndex() {\n        return this.platformHelper.hdIndex\n    }\n\n    getExternalActiveIndex() {\n        return this.externalHelper.hdIndex\n    }\n\n    getBaseAddress() {\n        return this.externalHelper.getAddressForIndex(0)\n    }\n\n    onnetworkchange(): void {\n        this.isInit = false\n        this.stakeAmount = new BN(0)\n\n        this.externalHelper.onNetworkChange().then(() => {\n            this.updateInitState()\n        })\n        this.internalHelper.onNetworkChange().then(() => {\n            this.updateInitState()\n        })\n        this.platformHelper.onNetworkChange().then(() => {\n            this.updateInitState()\n        })\n\n        // TODO: Handle EVM changes\n    }\n\n    async buildUnsignedTransaction(orders: (ITransaction | UTXO)[], addr: string, memo?: Buffer) {\n        const changeAddress = this.getChangeAddressAvm()\n        const derivedAddresses: string[] = this.getDerivedAddresses()\n        const utxoset = this.getUTXOSet()\n\n        return buildUnsignedTransaction(\n            orders,\n            addr,\n            derivedAddresses,\n            utxoset,\n            changeAddress,\n            memo\n        )\n    }\n\n    findExternalAddressIndex(address: string): number | null {\n        // TODO: Look for P addresses too\n        let indexX = this.externalHelper.findAddressIndex(address)\n        let indexP = this.platformHelper.findAddressIndex(address)\n\n        let index = indexX !== null ? indexX : indexP\n\n        if (indexX === null && indexP === null) throw new Error('Address not found.')\n        return index\n    }\n\n    async signMessageByExternalAddress(msgStr: string, address: string) {\n        let index = this.findExternalAddressIndex(address)\n        if (index === null) throw new Error('Address not found.')\n        return await this.signMessageByExternalIndex(msgStr, index)\n    }\n\n    async signMessageByExternalIndex(msgStr: string, index: number): Promise<string> {\n        let digest = digestMessage(msgStr)\n\n        // Convert to the other Buffer and sign\n        let digestHex = digest.toString('hex')\n        let digestBuff = Buffer.from(digestHex, 'hex')\n\n        return await this.signHashByExternalIndex(index, digestBuff)\n    }\n\n    async signMessage(msg: string, address: string) {\n        return await this.signMessageByExternalAddress(msg, address)\n    }\n\n    abstract async signHashByExternalIndex(index: number, hash: Buffer): Promise<string>\n}\nexport { HdWalletCore }\n","// interface IHistoryParsedBaseTx{\n//     sent:\n//     received:\n// }\n\nimport { ITransactionData, UTXO } from '@/store/modules/history/types'\nimport { WalletType } from '@/js/wallets/types'\nimport { BN } from 'avalanche'\nimport { AVMConstants } from 'avalanche/dist/apis/avm'\n\n// Summary item returned for each transaction\nexport interface BaseTxSummary {\n    tokens: {\n        [assetId: string]: BaseTxAssetSummary\n    }\n    collectibles: BaseTxNFTSummary\n}\n\ninterface TokenSummaryResult {\n    [assetID: string]: BaseTxAssetSummary\n}\n\nexport interface BaseTxNFTSummary {\n    received: NFTSummaryResultDict\n    sent: NFTSummaryResultDict\n}\n\ninterface NFTSummaryResultDict {\n    assets: {\n        [assetID: string]: UTXO[]\n    }\n    addresses: string[]\n}\n\n// export interface BaseTxNFTSummary {\n//     sent: UTXO[]\n//     received: UTXO[]\n// }\n\nexport interface BaseTxAssetSummary {\n    amount: BN\n    payload: string | undefined\n    groupNum: number\n    addresses: string[]\n}\n\n// Used with tokens\nfunction addToDict(\n    assetId: string,\n    amount: BN,\n    dict: TokenSummaryResult,\n    utxo: UTXO,\n    addresses: string[]\n) {\n    if (dict[assetId]) {\n        dict[assetId].amount = dict[assetId].amount.add(amount)\n\n        let addrDiff = addresses.filter((addr) => !dict[assetId].addresses.includes(addr))\n        dict[assetId].addresses.push(...addrDiff)\n    } else {\n        dict[assetId] = {\n            amount: amount,\n            payload: utxo.payload,\n            groupNum: utxo.groupID,\n            addresses: addresses,\n        }\n    }\n}\n\nfunction getNFTsSummary(tx: ITransactionData, wallet: WalletType): BaseTxNFTSummary {\n    let nftLoss = getLossNFT(tx, wallet)\n    let nftGain = getGainNFT(tx, wallet)\n    return {\n        sent: nftLoss,\n        received: nftGain,\n    }\n}\n\nfunction getLossNFT(tx: ITransactionData, wallet: WalletType): NFTSummaryResultDict {\n    let walletAddrs = wallet.getHistoryAddresses()\n    let addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    let inputs = tx.inputs || []\n    let outputs = tx.outputs\n\n    let loss: NFTSummaryResultDict = {\n        assets: {},\n        addresses: [],\n    }\n\n    let nfts = inputs.filter((input) => {\n        let type = input.output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    let nftsOuts = outputs.filter((output) => {\n        let type = output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    for (var i = 0; i < nfts.length; i++) {\n        let utxo = nfts[i].output\n        let owners = utxo.addresses\n        let assetID = utxo.assetID\n\n        let intersect = owners.filter((addr) => addrsStripped.includes(addr))\n\n        // Did we lose it?\n        if (intersect.length > 0) {\n            if (loss.assets[assetID]) {\n                loss.assets[assetID].push(utxo)\n            } else {\n                loss.assets[assetID] = [utxo]\n            }\n\n            // Who did we lose it to?\n            for (var n = 0; i < nftsOuts.length; n++) {\n                let nftOut = nftsOuts[n]\n                let doesMatch = nftOut.groupID === utxo.groupID && nftOut.assetID === utxo.assetID\n                let addrNotAdded = nftOut.addresses.filter((addr) => !loss.addresses.includes(addr))\n                if (doesMatch) {\n                    loss.addresses.push(...addrNotAdded)\n                    break\n                }\n            }\n        }\n    }\n\n    return loss\n}\n\nfunction getGainNFT(tx: ITransactionData, wallet: WalletType): NFTSummaryResultDict {\n    let walletAddrs = wallet.getHistoryAddresses()\n    let addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    let inputs = tx.inputs || []\n    let outputs = tx.outputs\n\n    let gain: NFTSummaryResultDict = {\n        assets: {},\n        addresses: [],\n    }\n\n    let nftsIns = inputs.filter((input) => {\n        let type = input.output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    let nftsOuts = outputs.filter((output) => {\n        let type = output.outputType\n        if (type === AVMConstants.NFTXFEROUTPUTID) return true\n        return false\n    })\n\n    for (var i = 0; i < nftsOuts.length; i++) {\n        let utxo = nftsOuts[i]\n        let owners = utxo.addresses\n        let assetID = utxo.assetID\n\n        let intersect = owners.filter((addr) => addrsStripped.includes(addr))\n\n        // Did we gain it?\n        if (intersect.length > 0) {\n            if (gain.assets[assetID]) {\n                gain.assets[assetID].push(utxo)\n            } else {\n                gain.assets[assetID] = [utxo]\n            }\n\n            // Who did we gain it from?\n            for (var n = 0; n < nftsIns.length; n++) {\n                let nftIn = nftsIns[n].output\n                let doesMatch = nftIn.groupID === utxo.groupID && nftIn.assetID === utxo.assetID\n                let addrNotAdded = nftIn.addresses.filter((addr) => !gain.addresses.includes(addr))\n                if (doesMatch) {\n                    gain.addresses.push(...addrNotAdded)\n                }\n            }\n        }\n    }\n\n    return gain\n}\n\nfunction getLoss(tx: ITransactionData, wallet: WalletType): TokenSummaryResult {\n    let ins = tx.inputs || []\n    let outs = tx.outputs\n\n    let walletAddrs = wallet.getHistoryAddresses()\n    let addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    let loss: TokenSummaryResult = {}\n\n    if (ins) {\n        for (let i = 0; i < ins.length; i++) {\n            let input = ins[i]\n            let utxo = input.output\n            let outputType = utxo.outputType\n            let isNft = outputType === AVMConstants.NFTXFEROUTPUTID\n\n            if (isNft) continue\n\n            let addrs = utxo.addresses\n\n            let intersect = addrs.filter((addr) => addrsStripped.includes(addr))\n\n            if (intersect.length === 0) continue\n\n            let assetId = utxo.assetID\n            let amount = utxo.amount\n            let amountBN = new BN(amount)\n\n            // Get who received this asset\n            let receivers: string[] = []\n            outs.forEach((utxo) => {\n                if (utxo.assetID === assetId) {\n                    let outAddrs = utxo.addresses\n                    // If not a wallet address and not added to receivers\n                    let targets = outAddrs.filter(\n                        (addr: string) => !addrsStripped.includes(addr) && !receivers.includes(addr)\n                    )\n                    receivers.push(...targets)\n                }\n            })\n\n            addToDict(assetId, amountBN, loss, utxo, receivers)\n        }\n    }\n\n    return loss\n}\n\nfunction getProfit(tx: ITransactionData, wallet: WalletType): TokenSummaryResult {\n    let outs = tx.outputs\n    let ins = tx.inputs || []\n\n    let walletAddrs = wallet.getHistoryAddresses()\n    let addrsStripped = walletAddrs.map((addr) => addr.split('-')[1])\n\n    let profit: TokenSummaryResult = {}\n\n    if (outs) {\n        for (let i = 0; i < outs.length; i++) {\n            let utxo = outs[i]\n            let outputType = utxo.outputType\n            let isNft = outputType === AVMConstants.NFTXFEROUTPUTID\n\n            // Skip NFTs\n            if (isNft) continue\n\n            let addrs = utxo.addresses\n\n            let intersect = addrs.filter((addr) => addrsStripped.includes(addr))\n\n            if (intersect.length === 0) continue\n\n            let assetId = utxo.assetID\n            let amount = utxo.amount\n            let amountBN = new BN(amount)\n\n            // Get who sent this to you\n            let senders: string[] = []\n            ins.forEach((input) => {\n                let utxo = input.output\n                if (utxo.assetID === assetId) {\n                    let outAddrs = utxo.addresses\n                    // If not a wallet address and not added to senders\n                    let targets = outAddrs.filter(\n                        (addr: string) => !addrsStripped.includes(addr) && !senders.includes(addr)\n                    )\n                    senders.push(...targets)\n                }\n            })\n\n            addToDict(assetId, amountBN, profit, utxo, senders)\n        }\n    }\n\n    return profit\n}\n\n// Finds the absolute gains and losses for the active wallet given transaction data from the explorer\nfunction getTransactionSummary(tx: ITransactionData, wallet: WalletType) {\n    let losses = getLoss(tx, wallet)\n    let profits = getProfit(tx, wallet)\n\n    let nftSummary = getNFTsSummary(tx, wallet)\n\n    // let nftLoss = getLossNFT(tx, wallet)\n    // let nftGain = getGainNFT()NFT(tx, wallet)\n    // console.log(nftLoss)\n\n    let sum: BaseTxSummary = {\n        tokens: {},\n        collectibles: {\n            sent: nftSummary.sent,\n            received: nftSummary.received,\n        },\n    }\n\n    // First the losses\n    for (let assetId in losses) {\n        let loss = losses[assetId]\n\n        sum.tokens[assetId] = {\n            amount: loss.amount.mul(new BN(-1)),\n            payload: loss.payload,\n            groupNum: loss.groupNum,\n            addresses: loss.addresses,\n        }\n    }\n\n    for (let assetId in profits) {\n        let profit = profits[assetId]\n\n        if (sum.tokens[assetId]) {\n            sum.tokens[assetId].amount = sum.tokens[assetId].amount.add(profit.amount)\n        } else {\n            sum.tokens[assetId] = {\n                amount: profit.amount,\n                payload: profit.payload,\n                groupNum: profit.groupNum,\n                addresses: profit.addresses,\n            }\n        }\n    }\n\n    return sum\n}\n\n/**\n * Given an array of transactions from the explorer, filter out duplicate transactions\n * @param txs\n */\nexport function filterDuplicateTransactions(txs: ITransactionData[]) {\n    let txsIds: string[] = []\n    let filtered: ITransactionData[] = []\n\n    for (var i = 0; i < txs.length; i++) {\n        let tx = txs[i]\n        let txId = tx.id\n\n        if (txsIds.includes(txId)) {\n            continue\n        } else {\n            txsIds.push(txId)\n            filtered.push(tx)\n        }\n    }\n    return filtered\n}\n\nexport { getTransactionSummary }\n","// import AppBtc from \"@ledgerhq/hw-app-btc\";\n//@ts-ignore\nimport AppAvax from '@obsidiansystems/hw-app-avalanche'\n//@ts-ignore\nimport Eth from '@ledgerhq/hw-app-eth'\n\nimport EthereumjsCommon from '@ethereumjs/common'\nimport { Transaction } from '@ethereumjs/tx'\n\nimport moment from 'moment'\nimport { Buffer, BN } from 'avalanche'\nimport HDKey from 'hdkey'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nconst bippath = require('bip32-path')\nimport createHash from 'create-hash'\nimport store from '@/store'\nimport { importPublic, publicToAddress, bnToRlp, rlp } from 'ethereumjs-util'\n\nimport { UTXO as AVMUTXO, UTXO, UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm/utxos'\nimport { AvaWalletCore } from '@/js/wallets/types'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport {\n    AVMConstants,\n    OperationTx,\n    SelectCredentialClass as AVMSelectCredentialClass,\n    TransferableOperation,\n    Tx as AVMTx,\n    UnsignedTx as AVMUnsignedTx,\n    ImportTx as AVMImportTx,\n} from 'avalanche/dist/apis/avm'\n\nimport {\n    ImportTx as PlatformImportTx,\n    ExportTx as PlatformExportTx,\n    Tx as PlatformTx,\n    UTXO as PlatformUTXO,\n    UnsignedTx as PlatformUnsignedTx,\n    PlatformVMConstants,\n    SelectCredentialClass as PlatformSelectCredentialClass,\n    AddDelegatorTx,\n    AddValidatorTx,\n} from 'avalanche/dist/apis/platformvm'\n\nimport {\n    UnsignedTx as EVMUnsignedTx,\n    ImportTx as EVMImportTx,\n    ExportTx as EVMExportTx,\n    Tx as EvmTx,\n    EVMConstants,\n    EVMInput,\n    SelectCredentialClass as EVMSelectCredentialClass,\n} from 'avalanche/dist/apis/evm'\n\nimport { Credential, SigIdx, Signature, UTXOResponse, Address } from 'avalanche/dist/common'\nimport { getPreferredHRP, PayloadBase } from 'avalanche/dist/utils'\nimport { HdWalletCore } from '@/js/wallets/HdWalletCore'\nimport { ILedgerAppConfig } from '@/store/types'\nimport { WalletNameType } from '@/js/wallets/types'\nimport { bnToBig, digestMessage } from '@/helpers/helper'\nimport { abiDecoder, web3 } from '@/evm'\nimport { AVA_ACCOUNT_PATH, ETH_ACCOUNT_PATH, LEDGER_ETH_ACCOUNT_PATH } from './MnemonicWallet'\nimport { ChainIdType } from '@/constants'\nimport { ParseableAvmTxEnum, ParseablePlatformEnum, ParseableEvmTxEnum } from '../TxHelper'\nimport { ILedgerBlockMessage } from '../../store/modules/ledger/types'\nimport Erc20Token from '@/js/Erc20Token'\nimport { WalletHelper } from '@/helpers/wallet_helper'\nimport { Utils, NetworkHelper, Network } from '@avalabs/avalanche-wallet-sdk'\n\nexport const MIN_EVM_SUPPORT_V = '0.5.3'\n\nclass LedgerWallet extends HdWalletCore implements AvaWalletCore {\n    app: AppAvax\n    ethApp: Eth\n    type: WalletNameType\n\n    ethAddress: string\n    ethBalance: BN\n    config: ILedgerAppConfig\n    ethHdNode: HDKey\n\n    constructor(app: AppAvax, hdkey: HDKey, config: ILedgerAppConfig, hdEth: HDKey, ethApp: Eth) {\n        super(hdkey, hdEth)\n        this.app = app\n        this.ethApp = ethApp\n        this.type = 'ledger'\n        this.config = config\n        this.ethHdNode = hdEth\n\n        if (hdEth) {\n            const ethKey = hdEth\n            const ethPublic = importPublic(ethKey.publicKey)\n            this.ethAddress = publicToAddress(ethPublic).toString('hex')\n            this.ethBalance = new BN(0)\n        } else {\n            this.ethAddress = ''\n            this.ethBalance = new BN(0)\n        }\n    }\n\n    static async fromApp(app: AppAvax, eth: Eth, config: ILedgerAppConfig) {\n        let res = await app.getWalletExtendedPublicKey(AVA_ACCOUNT_PATH)\n\n        let hd = new HDKey()\n        hd.publicKey = res.public_key\n        hd.chainCode = res.chain_code\n\n        let ethRes = await eth.getAddress(LEDGER_ETH_ACCOUNT_PATH, true, true)\n        let hdEth = new HDKey()\n        // @ts-ignore\n        hdEth.publicKey = Buffer.from(ethRes.publicKey, 'hex')\n        // @ts-ignore\n        hdEth.chainCode = Buffer.from(ethRes.chainCode, 'hex')\n\n        return new LedgerWallet(app, hd, config, hdEth, eth)\n    }\n\n    // Returns an array of derivation paths that need to sign this transaction\n    // Used with signTransactionHash and signTransactionParsable\n    getTransactionPaths<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType\n    ): { paths: string[]; isAvaxOnly: boolean } {\n        // TODO: This is a nasty fix. Remove when AJS is updated.\n        unsignedTx.toBuffer()\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n\n        let ins = tx.getIns()\n        let operations: TransferableOperation[] = []\n\n        // Try to get operations, it will fail if there are none, ignore and continue\n        try {\n            operations = (tx as OperationTx).getOperations()\n        } catch (e) {\n            console.log(e)\n        }\n\n        let items = ins\n        if (\n            (txType === AVMConstants.IMPORTTX && chainId === 'X') ||\n            (txType === PlatformVMConstants.IMPORTTX && chainId === 'P')\n        ) {\n            items = ((tx as AVMImportTx) || PlatformImportTx).getImportInputs()\n        }\n\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        let paths: string[] = []\n\n        let isAvaxOnly = true\n\n        // Collect derivation paths for source addresses\n        for (let i = 0; i < items.length; i++) {\n            let item = items[i]\n\n            let assetId = bintools.cb58Encode(item.getAssetID())\n            // @ts-ignore\n            if (assetId !== store.state.Assets.AVA_ASSET_ID) {\n                isAvaxOnly = false\n            }\n\n            let sigidxs: SigIdx[] = item.getInput().getSigIdxs()\n            let sources = sigidxs.map((sigidx) => sigidx.getSource())\n            let addrs: string[] = sources.map((source) => {\n                return bintools.addressToString(hrp, chainId, source)\n            })\n\n            for (let j = 0; j < addrs.length; j++) {\n                let srcAddr = addrs[j]\n                let pathStr = this.getPathFromAddress(srcAddr) // returns change/index\n\n                paths.push(pathStr)\n            }\n        }\n\n        // Do the Same for operational inputs, if there are any...\n        for (let i = 0; i < operations.length; i++) {\n            let op = operations[i]\n            let sigidxs: SigIdx[] = op.getOperation().getSigIdxs()\n            let sources = sigidxs.map((sigidx) => sigidx.getSource())\n            let addrs: string[] = sources.map((source) => {\n                return bintools.addressToString(hrp, chainId, source)\n            })\n\n            for (let j = 0; j < addrs.length; j++) {\n                let srcAddr = addrs[j]\n                let pathStr = this.getPathFromAddress(srcAddr) // returns change/index\n\n                paths.push(pathStr)\n            }\n        }\n\n        return { paths, isAvaxOnly }\n    }\n\n    pathsToUniqueBipPaths(paths: string[]) {\n        let uniquePaths = paths.filter((val: any, i: number) => {\n            return paths.indexOf(val) === i\n        })\n\n        let bip32Paths = uniquePaths.map((path) => {\n            return bippath.fromString(path, false)\n        })\n\n        return bip32Paths\n    }\n\n    getChangeBipPath<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType\n    ) {\n        if (chainId === 'C') {\n            return null\n        }\n\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n\n        const chainChangePath = this.getChangePath(chainId).split('m/')[1]\n        let changeIdx = this.getChangeIndex(chainId)\n        // If change and destination paths are the same\n        // it can cause ledger to not display the destination amt.\n        // Since platform helper does not have internal/external\n        // path for change (it uses the next address)\n        // there can be an address collisions.\n        if (\n            (txType === PlatformVMConstants.IMPORTTX || txType === PlatformVMConstants.EXPORTTX) &&\n            this.platformHelper.hdIndex === this.externalHelper.hdIndex\n        ) {\n            return null\n        } else if (\n            txType === PlatformVMConstants.ADDVALIDATORTX ||\n            txType === PlatformVMConstants.ADDDELEGATORTX\n        ) {\n            changeIdx = this.platformHelper.getFirstAvailableIndex()\n        }\n\n        return bippath.fromString(`${AVA_ACCOUNT_PATH}/${chainChangePath}/${changeIdx}`)\n    }\n\n    getCredentials<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        paths: string[],\n        sigMap: any,\n        chainId: ChainIdType\n    ): Credential[] {\n        let creds: Credential[] = []\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n\n        // @ts-ignore\n        let ins = tx.getIns ? tx.getIns() : []\n        let operations: TransferableOperation[] = []\n        let evmInputs: EVMInput[] = []\n\n        let items = ins\n        if (\n            (txType === AVMConstants.IMPORTTX && chainId === 'X') ||\n            (txType === PlatformVMConstants.IMPORTTX && chainId === 'P') ||\n            (txType === EVMConstants.IMPORTTX && chainId === 'C')\n        ) {\n            items = ((tx as AVMImportTx) || PlatformImportTx || EVMImportTx).getImportInputs()\n        }\n\n        // Try to get operations, it will fail if there are none, ignore and continue\n        try {\n            operations = (tx as OperationTx).getOperations()\n        } catch (e) {\n            console.error(e)\n        }\n\n        let CredentialClass\n        if (chainId === 'X') {\n            CredentialClass = AVMSelectCredentialClass\n        } else if (chainId === 'P') {\n            CredentialClass = PlatformSelectCredentialClass\n        } else {\n            CredentialClass = EVMSelectCredentialClass\n        }\n\n        // Try to get evm inputs, it will fail if there are none, ignore and continue\n        try {\n            evmInputs = (tx as EVMExportTx).getInputs()\n        } catch (e) {\n            console.error(e)\n        }\n\n        for (let i = 0; i < items.length; i++) {\n            const sigidxs: SigIdx[] = items[i].getInput().getSigIdxs()\n            const cred: Credential = CredentialClass(items[i].getInput().getCredentialID())\n\n            for (let j = 0; j < sigidxs.length; j++) {\n                let pathIndex = i + j\n                let pathStr = paths[pathIndex]\n\n                let sigRaw = sigMap.get(pathStr)\n                let sigBuff = Buffer.from(sigRaw)\n                const sig: Signature = new Signature()\n                sig.fromBuffer(sigBuff)\n                cred.addSignature(sig)\n            }\n            creds.push(cred)\n        }\n\n        for (let i = 0; i < operations.length; i++) {\n            let op = operations[i].getOperation()\n            const sigidxs: SigIdx[] = op.getSigIdxs()\n            const cred: Credential = CredentialClass(op.getCredentialID())\n\n            for (let j = 0; j < sigidxs.length; j++) {\n                let pathIndex = items.length + i + j\n                let pathStr = paths[pathIndex]\n\n                let sigRaw = sigMap.get(pathStr)\n                let sigBuff = Buffer.from(sigRaw)\n                const sig: Signature = new Signature()\n                sig.fromBuffer(sigBuff)\n                cred.addSignature(sig)\n            }\n            creds.push(cred)\n        }\n\n        for (let i = 0; i < evmInputs.length; i++) {\n            let evmInput = evmInputs[i]\n            const sigidxs: SigIdx[] = evmInput.getSigIdxs()\n            const cred: Credential = CredentialClass(evmInput.getCredentialID())\n\n            for (let j = 0; j < sigidxs.length; j++) {\n                let pathIndex = items.length + i + j\n                let pathStr = paths[pathIndex]\n\n                let sigRaw = sigMap.get(pathStr)\n                let sigBuff = Buffer.from(sigRaw)\n                const sig: Signature = new Signature()\n                sig.fromBuffer(sigBuff)\n                cred.addSignature(sig)\n            }\n            creds.push(cred)\n        }\n\n        return creds\n    }\n\n    // Used for non parsable transactions.\n    // Ideally we wont use this function at all, but ledger is not ready yet.\n    async signTransactionHash<\n        UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx,\n        SignedTx extends AVMTx | PlatformTx | EvmTx\n    >(unsignedTx: UnsignedTx, paths: string[], chainId: ChainIdType): Promise<SignedTx> {\n        let txbuff = unsignedTx.toBuffer()\n        const msg: Buffer = Buffer.from(createHash('sha256').update(txbuff).digest())\n\n        try {\n            store.commit('Ledger/openModal', {\n                title: 'Sign Hash',\n                messages: [],\n                info: msg.toString('hex').toUpperCase(),\n            })\n\n            let bip32Paths = this.pathsToUniqueBipPaths(paths)\n\n            // Sign the msg with ledger\n            const accountPathSource = chainId === 'C' ? ETH_ACCOUNT_PATH : AVA_ACCOUNT_PATH\n            const accountPath = bippath.fromString(`${accountPathSource}`)\n            let sigMap = await this.app.signHash(accountPath, bip32Paths, msg)\n            store.commit('Ledger/closeModal')\n\n            let creds: Credential[] = this.getCredentials<UnsignedTx>(\n                unsignedTx,\n                paths,\n                sigMap,\n                chainId\n            )\n\n            let signedTx\n            switch (chainId) {\n                case 'X':\n                    signedTx = new AVMTx(unsignedTx as AVMUnsignedTx, creds)\n                    break\n                case 'P':\n                    signedTx = new PlatformTx(unsignedTx as PlatformUnsignedTx, creds)\n                    break\n                case 'C':\n                    signedTx = new EvmTx(unsignedTx as EVMUnsignedTx, creds)\n                    break\n            }\n\n            return signedTx as SignedTx\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            console.error(e)\n            throw e\n        }\n    }\n\n    // Used for signing transactions that are parsable\n    async signTransactionParsable<\n        UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx,\n        SignedTx extends AVMTx | PlatformTx | EvmTx\n    >(unsignedTx: UnsignedTx, paths: string[], chainId: ChainIdType): Promise<SignedTx> {\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n        let parseableTxs = {\n            X: ParseableAvmTxEnum,\n            P: ParseablePlatformEnum,\n            C: ParseableEvmTxEnum,\n        }[chainId]\n\n        let title = `Sign ${parseableTxs[txType]}`\n\n        let bip32Paths = this.pathsToUniqueBipPaths(paths)\n\n        const accountPath =\n            chainId === 'C'\n                ? bippath.fromString(`${ETH_ACCOUNT_PATH}`)\n                : bippath.fromString(`${AVA_ACCOUNT_PATH}`)\n        let txbuff = unsignedTx.toBuffer()\n        let changePath = this.getChangeBipPath(unsignedTx, chainId)\n        let messages = this.getTransactionMessages<UnsignedTx>(unsignedTx, chainId, changePath)\n\n        try {\n            store.commit('Ledger/openModal', {\n                title: title,\n                messages: messages,\n                info: null,\n            })\n\n            let ledgerSignedTx = await this.app.signTransaction(\n                accountPath,\n                bip32Paths,\n                txbuff,\n                changePath\n            )\n\n            let sigMap = ledgerSignedTx.signatures\n            let creds = this.getCredentials<UnsignedTx>(unsignedTx, paths, sigMap, chainId)\n\n            let signedTx\n            switch (chainId) {\n                case 'X':\n                    signedTx = new AVMTx(unsignedTx as AVMUnsignedTx, creds)\n                    break\n                case 'P':\n                    signedTx = new PlatformTx(unsignedTx as PlatformUnsignedTx, creds)\n                    break\n                case 'C':\n                    signedTx = new EvmTx(unsignedTx as EVMUnsignedTx, creds)\n                    break\n            }\n\n            return signedTx as SignedTx\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            console.error(e)\n            throw e\n        }\n    }\n\n    getOutputMsgs<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType,\n        changePath: null | { toPathArray: () => number[] }\n    ): ILedgerBlockMessage[] {\n        let messages: ILedgerBlockMessage[] = []\n        let hrp = getPreferredHRP(ava.getNetworkID())\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n\n        // @ts-ignore\n        let outs\n        if (\n            (txType === AVMConstants.EXPORTTX && chainId === 'X') ||\n            (txType === PlatformVMConstants.EXPORTTX && chainId === 'P')\n        ) {\n            outs = (tx as PlatformExportTx).getExportOutputs()\n        } else if (txType === EVMConstants.EXPORTTX && chainId === 'C') {\n            outs = (tx as EVMExportTx).getExportedOutputs()\n        } else {\n            outs = (tx as PlatformExportTx).getOuts()\n        }\n\n        let destinationChain = chainId\n        if (chainId === 'C' && txType === EVMConstants.EXPORTTX) destinationChain = 'X'\n\n        if (destinationChain === 'C') {\n            for (let i = 0; i < outs.length; i++) {\n                // @ts-ignore\n                const value = outs[i].getAddress()\n                const addr = bintools.addressToString(hrp, chainId, value)\n                // @ts-ignore\n                const amt = bnToBig(outs[i].getAmount(), 9)\n\n                messages.push({\n                    title: 'Output',\n                    value: `${addr} - ${amt.toString()} AVAX`,\n                })\n            }\n        } else {\n            let changeIdx = changePath?.toPathArray()[changePath?.toPathArray().length - 1]\n            let changeAddr = this.getChangeFromIndex(changeIdx, destinationChain)\n\n            for (let i = 0; i < outs.length; i++) {\n                outs[i]\n                    .getOutput()\n                    .getAddresses()\n                    .forEach((value) => {\n                        const addr = bintools.addressToString(hrp, chainId, value)\n                        // @ts-ignore\n                        const amt = bnToBig(outs[i].getOutput().getAmount(), 9)\n\n                        if (!changePath || changeAddr !== addr)\n                            messages.push({\n                                title: 'Output',\n                                value: `${addr} - ${amt.toString()} AVAX`,\n                            })\n                    })\n            }\n        }\n\n        return messages\n    }\n\n    getValidateDelegateMsgs<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType\n    ): ILedgerBlockMessage[] {\n        let tx =\n            ((unsignedTx as\n                | AVMUnsignedTx\n                | PlatformUnsignedTx).getTransaction() as AddValidatorTx) || AddDelegatorTx\n        let txType = tx.getTxType()\n        let messages: ILedgerBlockMessage[] = []\n\n        if (\n            (txType === PlatformVMConstants.ADDDELEGATORTX && chainId === 'P') ||\n            (txType === PlatformVMConstants.ADDVALIDATORTX && chainId === 'P')\n        ) {\n            const format = 'YYYY-MM-DD H:mm:ss UTC'\n\n            const nodeID = bintools.cb58Encode(tx.getNodeID())\n            const startTime = moment(tx.getStartTime().toNumber() * 1000)\n                .utc()\n                .format(format)\n\n            const endTime = moment(tx.getEndTime().toNumber() * 1000)\n                .utc()\n                .format(format)\n\n            const stakeAmt = bnToBig(tx.getStakeAmount(), 9)\n\n            const rewardOwners = tx.getRewardOwners()\n            let hrp = ava.getHRP()\n            const rewardAddrs = rewardOwners\n                .getOutput()\n                .getAddresses()\n                .map((addr) => {\n                    return bintools.addressToString(hrp, chainId, addr)\n                })\n\n            messages.push({ title: 'NodeID', value: nodeID })\n            messages.push({ title: 'Start Time', value: startTime })\n            messages.push({ title: 'End Time', value: endTime })\n            messages.push({ title: 'Total Stake', value: `${stakeAmt} AVAX` })\n            messages.push({\n                title: 'Stake',\n                value: `${stakeAmt} to ${this.platformHelper.getCurrentAddress()}`,\n            })\n            messages.push({\n                title: 'Reward to',\n                value: `${rewardAddrs.join('\\n')}`,\n            })\n            // @ts-ignore\n            if (tx.delegationFee) {\n                // @ts-ignore\n                messages.push({ title: 'Delegation Fee', value: `${tx.delegationFee}%` })\n            }\n            messages.push({ title: 'Fee', value: '0' })\n        }\n\n        return messages\n    }\n\n    getFeeMsgs<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType\n    ): ILedgerBlockMessage[] {\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n        let messages = []\n\n        if (\n            (txType === AVMConstants.BASETX && chainId === 'X') ||\n            (txType === AVMConstants.EXPORTTX && chainId === 'X') ||\n            (txType === AVMConstants.IMPORTTX && chainId === 'X') ||\n            (txType === PlatformVMConstants.EXPORTTX && chainId === 'P') ||\n            (txType === PlatformVMConstants.IMPORTTX && chainId === 'P') ||\n            (txType === EVMConstants.EXPORTTX && chainId === 'C') ||\n            (txType === EVMConstants.IMPORTTX && chainId === 'C')\n        ) {\n            messages.push({ title: 'Fee', value: `${0.001} AVAX` })\n        }\n\n        return messages\n    }\n\n    // Given the unsigned transaction returns an array of messages that will be displayed on ledgegr window\n    getTransactionMessages<UnsignedTx extends AVMUnsignedTx | PlatformUnsignedTx | EVMUnsignedTx>(\n        unsignedTx: UnsignedTx,\n        chainId: ChainIdType,\n        changePath: null | { toPathArray: () => number[] }\n    ): ILedgerBlockMessage[] {\n        let messages: ILedgerBlockMessage[] = []\n\n        const outputMessages = this.getOutputMsgs(unsignedTx, chainId, changePath)\n        messages.push(...outputMessages)\n\n        const validateDelegateMessages = this.getValidateDelegateMsgs(\n            unsignedTx as AVMUnsignedTx | PlatformUnsignedTx,\n            chainId\n        )\n        messages.push(...validateDelegateMessages)\n\n        const feeMessages = this.getFeeMsgs(unsignedTx, chainId)\n        messages.push(...feeMessages)\n\n        return messages\n    }\n\n    getEvmTransactionMessages(tx: Transaction): ILedgerBlockMessage[] {\n        let gasPrice = tx.gasPrice\n        let gasLimit = tx.gasLimit\n        let totFee = gasPrice.mul(new BN(gasLimit))\n        let feeNano = Utils.bnToBig(totFee, 9)\n\n        let msgs: ILedgerBlockMessage[] = []\n        try {\n            let test = '0x' + tx.data.toString('hex')\n            let data = abiDecoder.decodeMethod(test)\n\n            let callMsg: ILedgerBlockMessage = {\n                title: 'Contract Call',\n                value: data.name,\n            }\n            let paramMsgs: ILedgerBlockMessage[] = data.params.map((param: any) => {\n                return {\n                    title: param.name,\n                    value: param.value,\n                }\n            })\n\n            let feeMsg: ILedgerBlockMessage = {\n                title: 'Fee',\n                value: feeNano.toLocaleString() + ' nAVAX',\n            }\n\n            msgs = [callMsg, ...paramMsgs, feeMsg]\n        } catch (e) {\n            console.log(e)\n        }\n        return msgs\n    }\n\n    async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n        let chainId: ChainIdType = 'X'\n\n        let parseableTxs = ParseableAvmTxEnum\n        let { paths, isAvaxOnly } = this.getTransactionPaths<AVMUnsignedTx>(unsignedTx, chainId)\n\n        // If ledger doesnt support parsing, sign hash\n        let canLedgerParse = this.config.version >= '0.3.1'\n        let isParsableType = txType in parseableTxs && isAvaxOnly\n\n        let signedTx\n        if (canLedgerParse && isParsableType) {\n            signedTx = await this.signTransactionParsable<AVMUnsignedTx, AVMTx>(\n                unsignedTx,\n                paths,\n                chainId\n            )\n        } else {\n            signedTx = await this.signTransactionHash<AVMUnsignedTx, AVMTx>(\n                unsignedTx,\n                paths,\n                chainId\n            )\n        }\n\n        store.commit('Ledger/closeModal')\n        return signedTx\n    }\n\n    async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n        let tx = unsignedTx.getTransaction()\n        let txType = tx.getTxType()\n        let chainId: ChainIdType = 'P'\n        let parseableTxs = ParseablePlatformEnum\n\n        let { paths, isAvaxOnly } = this.getTransactionPaths<PlatformUnsignedTx>(\n            unsignedTx,\n            chainId\n        )\n        // If ledger doesnt support parsing, sign hash\n        let canLedgerParse = this.config.version >= '0.3.1'\n        let isParsableType = txType in parseableTxs && isAvaxOnly\n\n        // TODO: Remove after ledger is fixed\n        // If UTXOS contain lockedStakeable funds always use sign hash\n        let txIns = unsignedTx.getTransaction().getIns()\n        for (var i = 0; i < txIns.length; i++) {\n            let typeID = txIns[i].getInput().getTypeID()\n            if (typeID === PlatformVMConstants.STAKEABLELOCKINID) {\n                canLedgerParse = false\n                break\n            }\n        }\n\n        // TODO: Remove after ledger update\n        // Ledger is not able to parse P/C atomic transactions\n        if (txType === PlatformVMConstants.EXPORTTX) {\n            const destChainBuff = (tx as PlatformExportTx).getDestinationChain()\n            // If destination chain is C chain, sign hash\n            const destChain = Network.idToChainAlias(bintools.cb58Encode(destChainBuff))\n            if (destChain === 'C') {\n                canLedgerParse = false\n            }\n        }\n        // TODO: Remove after ledger update\n        if (txType === PlatformVMConstants.IMPORTTX) {\n            const sourceChainBuff = (tx as PlatformImportTx).getSourceChain()\n            // If destination chain is C chain, sign hash\n            const sourceChain = Network.idToChainAlias(bintools.cb58Encode(sourceChainBuff))\n            if (sourceChain === 'C') {\n                canLedgerParse = false\n            }\n        }\n\n        let signedTx\n        if (canLedgerParse && isParsableType) {\n            signedTx = await this.signTransactionParsable<PlatformUnsignedTx, PlatformTx>(\n                unsignedTx,\n                paths,\n                chainId\n            )\n        } else {\n            signedTx = await this.signTransactionHash<PlatformUnsignedTx, PlatformTx>(\n                unsignedTx,\n                paths,\n                chainId\n            )\n        }\n        store.commit('Ledger/closeModal')\n        return signedTx\n    }\n\n    async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n        // TODO: Might need to upgrade paths array to:\n        //  paths = Array(utxoSet.getAllUTXOs().length).fill('0/0'),\n        let tx = unsignedTx.getTransaction()\n        let typeId = tx.getTxType()\n\n        let canLedgerParse = true\n\n        let paths = ['0/0']\n        if (typeId === EVMConstants.EXPORTTX) {\n            let ins = (tx as EVMExportTx).getInputs()\n            paths = ins.map((input) => '0/0')\n        } else if (typeId === EVMConstants.IMPORTTX) {\n            let ins = (tx as EVMImportTx).getImportInputs()\n            paths = ins.map((input) => '0/0')\n        }\n\n        // TODO: Remove after ledger update\n        // Ledger is not able to parse P/C atomic transactions\n        if (typeId === EVMConstants.EXPORTTX) {\n            const destChainBuff = (tx as EVMExportTx).getDestinationChain()\n            // If destination chain is C chain, sign hash\n            const destChain = Network.idToChainAlias(bintools.cb58Encode(destChainBuff))\n            if (destChain === 'P') {\n                canLedgerParse = false\n            }\n        }\n        // TODO: Remove after ledger update\n        if (typeId === EVMConstants.IMPORTTX) {\n            const sourceChainBuff = (tx as EVMImportTx).getSourceChain()\n            // If destination chain is C chain, sign hash\n            const sourceChain = Network.idToChainAlias(bintools.cb58Encode(sourceChainBuff))\n            if (sourceChain === 'P') {\n                canLedgerParse = false\n            }\n        }\n\n        let txSigned\n        if (canLedgerParse) {\n            txSigned = (await this.signTransactionParsable(unsignedTx, paths, 'C')) as EvmTx\n        } else {\n            txSigned = (await this.signTransactionHash(unsignedTx, paths, 'C')) as EvmTx\n        }\n        store.commit('Ledger/closeModal')\n        return txSigned\n    }\n\n    async signEvm(tx: Transaction) {\n        const rawUnsignedTx = rlp.encode([\n            bnToRlp(tx.nonce),\n            bnToRlp(tx.gasPrice),\n            bnToRlp(tx.gasLimit),\n            tx.to !== undefined ? tx.to.buf : Buffer.from([]),\n            bnToRlp(tx.value),\n            tx.data,\n            bnToRlp(new BN(tx.getChainId())),\n            Buffer.from([]),\n            Buffer.from([]),\n        ])\n\n        try {\n            let msgs = this.getEvmTransactionMessages(tx)\n\n            // Open Modal Prompt\n            store.commit('Ledger/openModal', {\n                title: 'Transfer',\n                messages: msgs,\n                info: null,\n            })\n            const signature = await this.ethApp.signTransaction(\n                LEDGER_ETH_ACCOUNT_PATH,\n                rawUnsignedTx.toString('hex')\n            )\n            store.commit('Ledger/closeModal')\n\n            const signatureBN = {\n                v: new BN(signature.v, 16),\n                r: new BN(signature.r, 16),\n                s: new BN(signature.s, 16),\n            }\n\n            const chainId = await web3.eth.getChainId()\n            const networkId = await web3.eth.net.getId()\n            const chainParams = {\n                common: EthereumjsCommon.forCustomChain(\n                    'mainnet',\n                    { networkId, chainId },\n                    'istanbul'\n                ),\n            }\n\n            const signedTx = Transaction.fromTxData(\n                {\n                    nonce: tx.nonce,\n                    gasPrice: tx.gasPrice,\n                    gasLimit: tx.gasLimit,\n                    to: tx.to,\n                    value: tx.value,\n                    data: tx.data,\n                    ...signatureBN,\n                },\n                chainParams\n            )\n            return signedTx\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            console.error(e)\n            throw e\n        }\n    }\n\n    getEvmAddress(): string {\n        return this.ethAddress\n    }\n\n    async getStake(): Promise<BN> {\n        this.stakeAmount = await WalletHelper.getStake(this)\n        return this.stakeAmount\n    }\n\n    async getEthBalance() {\n        let bal = await WalletHelper.getEthBalance(this)\n        this.ethBalance = bal\n        return bal\n    }\n\n    async getUTXOs(): Promise<void> {\n        // TODO: Move to shared file\n        this.isFetchUtxos = true\n        // If we are waiting for helpers to initialize delay the call\n        let isInit =\n            this.externalHelper.isInit && this.internalHelper.isInit && this.platformHelper.isInit\n        if (!isInit) {\n            setTimeout(() => {\n                this.getUTXOs()\n            }, 1000)\n            return\n        }\n\n        super.getUTXOs()\n        this.getStake()\n        this.getEthBalance()\n        return\n    }\n\n    getPathFromAddress(address: string) {\n        let externalAddrs = this.externalHelper.getExtendedAddresses()\n        let internalAddrs = this.internalHelper.getExtendedAddresses()\n        let platformAddrs = this.platformHelper.getExtendedAddresses()\n\n        let extIndex = externalAddrs.indexOf(address)\n        let intIndex = internalAddrs.indexOf(address)\n        let platformIndex = platformAddrs.indexOf(address)\n\n        if (extIndex >= 0) {\n            return `0/${extIndex}`\n        } else if (intIndex >= 0) {\n            return `1/${intIndex}`\n        } else if (platformIndex >= 0) {\n            return `0/${platformIndex}`\n        } else if (address[0] === 'C') {\n            return '0/0'\n        } else {\n            throw 'Unable to find source address.'\n        }\n    }\n\n    async issueBatchTx(\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: Buffer | undefined\n    ): Promise<string> {\n        return await WalletHelper.issueBatchTx(this, orders, addr, memo)\n    }\n\n    async delegate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.delegate(this, nodeID, amt, start, end, rewardAddress, utxos)\n    }\n\n    async validate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.validate(\n            this,\n            nodeID,\n            amt,\n            start,\n            end,\n            delegationFee,\n            rewardAddress,\n            utxos\n        )\n    }\n\n    async signHashByExternalIndex(index: number, hash: Buffer) {\n        let pathStr = `0/${index}`\n        const addressPath = bippath.fromString(pathStr, false)\n        const accountPath = bippath.fromString(`${AVA_ACCOUNT_PATH}`)\n\n        store.commit('Ledger/openModal', {\n            title: `Sign Hash`,\n            info: hash.toString('hex').toUpperCase(),\n        })\n\n        try {\n            let sigMap = await this.app.signHash(accountPath, [addressPath], hash)\n            store.commit('Ledger/closeModal')\n            let signed = sigMap.get(pathStr)\n            return bintools.cb58Encode(signed)\n        } catch (e) {\n            store.commit('Ledger/closeModal')\n            throw e\n        }\n    }\n\n    async createNftFamily(name: string, symbol: string, groupNum: number) {\n        return await WalletHelper.createNftFamily(this, name, symbol, groupNum)\n    }\n\n    async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n        return await WalletHelper.mintNft(this, mintUtxo, payload, quantity)\n    }\n\n    async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n        return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit)\n    }\n\n    async estimateGas(to: string, amount: BN, token: Erc20Token): Promise<number> {\n        return await WalletHelper.estimateGas(this, to, amount, token)\n    }\n\n    async sendERC20(\n        to: string,\n        amount: BN,\n        gasPrice: BN,\n        gasLimit: number,\n        token: Erc20Token\n    ): Promise<string> {\n        // throw 'Not Implemented'\n        return await WalletHelper.sendErc20(this, to, amount, gasPrice, gasLimit, token)\n    }\n}\n\nexport { LedgerWallet }\n","var isoLangs = {\n    ab: {\n        name: 'Abkhaz',\n        nativeName: 'аҧсуа',\n    },\n    aa: {\n        name: 'Afar',\n        nativeName: 'Afaraf',\n    },\n    af: {\n        name: 'Afrikaans',\n        nativeName: 'Afrikaans',\n    },\n    ak: {\n        name: 'Akan',\n        nativeName: 'Akan',\n    },\n    sq: {\n        name: 'Albanian',\n        nativeName: 'Shqip',\n    },\n    am: {\n        name: 'Amharic',\n        nativeName: 'አማርኛ',\n    },\n    ar: {\n        name: 'Arabic',\n        nativeName: 'العربية',\n    },\n    an: {\n        name: 'Aragonese',\n        nativeName: 'Aragonés',\n    },\n    hy: {\n        name: 'Armenian',\n        nativeName: 'Հայերեն',\n    },\n    as: {\n        name: 'Assamese',\n        nativeName: 'অসমীয়া',\n    },\n    av: {\n        name: 'Avaric',\n        nativeName: 'авар мацӀ, магӀарул мацӀ',\n    },\n    ae: {\n        name: 'Avestan',\n        nativeName: 'avesta',\n    },\n    ay: {\n        name: 'Aymara',\n        nativeName: 'aymar aru',\n    },\n    az: {\n        name: 'Azerbaijani',\n        nativeName: 'azərbaycan dili',\n    },\n    bm: {\n        name: 'Bambara',\n        nativeName: 'bamanankan',\n    },\n    ba: {\n        name: 'Bashkir',\n        nativeName: 'башҡорт теле',\n    },\n    eu: {\n        name: 'Basque',\n        nativeName: 'euskara, euskera',\n    },\n    be: {\n        name: 'Belarusian',\n        nativeName: 'Беларуская',\n    },\n    bn: {\n        name: 'Bengali',\n        nativeName: 'বাংলা',\n    },\n    bh: {\n        name: 'Bihari',\n        nativeName: 'भोजपुरी',\n    },\n    bi: {\n        name: 'Bislama',\n        nativeName: 'Bislama',\n    },\n    bs: {\n        name: 'Bosnian',\n        nativeName: 'bosanski jezik',\n    },\n    br: {\n        name: 'Breton',\n        nativeName: 'brezhoneg',\n    },\n    bg: {\n        name: 'Bulgarian',\n        nativeName: 'български език',\n    },\n    my: {\n        name: 'Burmese',\n        nativeName: 'ဗမာစာ',\n    },\n    ca: {\n        name: 'Catalan; Valencian',\n        nativeName: 'Català',\n    },\n    ch: {\n        name: 'Chamorro',\n        nativeName: 'Chamoru',\n    },\n    ce: {\n        name: 'Chechen',\n        nativeName: 'нохчийн мотт',\n    },\n    ny: {\n        name: 'Chichewa; Chewa; Nyanja',\n        nativeName: 'chiCheŵa, chinyanja',\n    },\n    cn: {\n        name: 'Chinese',\n        nativeName: '中文 (Zhōngwén), 汉语, 漢語',\n    },\n    zh_hans: {\n        name: 'Chinese (Simplified)',\n        nativeName: '汉语',\n    },\n    zh_hant: {\n        name: 'Chinese (Traditional)',\n        nativeName: '漢語',\n    },\n    cv: {\n        name: 'Chuvash',\n        nativeName: 'чӑваш чӗлхи',\n    },\n    kw: {\n        name: 'Cornish',\n        nativeName: 'Kernewek',\n    },\n    co: {\n        name: 'Corsican',\n        nativeName: 'corsu, lingua corsa',\n    },\n    cr: {\n        name: 'Cree',\n        nativeName: 'ᓀᐦᐃᔭᐍᐏᐣ',\n    },\n    hr: {\n        name: 'Croatian',\n        nativeName: 'hrvatski',\n    },\n    cs: {\n        name: 'Czech',\n        nativeName: 'česky, čeština',\n    },\n    da: {\n        name: 'Danish',\n        nativeName: 'dansk',\n    },\n    dv: {\n        name: 'Divehi; Dhivehi; Maldivian;',\n        nativeName: 'ދިވެހި',\n    },\n    nl: {\n        name: 'Dutch',\n        nativeName: 'Nederlands, Vlaams',\n    },\n    en: {\n        name: 'English',\n        nativeName: 'English',\n    },\n    eo: {\n        name: 'Esperanto',\n        nativeName: 'Esperanto',\n    },\n    et: {\n        name: 'Estonian',\n        nativeName: 'eesti, eesti keel',\n    },\n    ee: {\n        name: 'Ewe',\n        nativeName: 'Eʋegbe',\n    },\n    fo: {\n        name: 'Faroese',\n        nativeName: 'føroyskt',\n    },\n    fj: {\n        name: 'Fijian',\n        nativeName: 'vosa Vakaviti',\n    },\n    fi: {\n        name: 'Finnish',\n        nativeName: 'suomi, suomen kieli',\n    },\n    fr: {\n        name: 'French',\n        nativeName: 'Français',\n    },\n    ff: {\n        name: 'Fula; Fulah; Pulaar; Pular',\n        nativeName: 'Fulfulde, Pulaar, Pular',\n    },\n    gl: {\n        name: 'Galician',\n        nativeName: 'Galego',\n    },\n    ka: {\n        name: 'Georgian',\n        nativeName: 'ქართული',\n    },\n    de: {\n        name: 'German',\n        nativeName: 'Deutsch',\n    },\n    el: {\n        name: 'Greek, Modern',\n        nativeName: 'Ελληνικά',\n    },\n    gn: {\n        name: 'Guaraní',\n        nativeName: 'Avañeẽ',\n    },\n    gu: {\n        name: 'Gujarati',\n        nativeName: 'ગુજરાતી',\n    },\n    ht: {\n        name: 'Haitian; Haitian Creole',\n        nativeName: 'Kreyòl ayisyen',\n    },\n    ha: {\n        name: 'Hausa',\n        nativeName: 'Hausa, هَوُسَ',\n    },\n    he: {\n        name: 'Hebrew (modern)',\n        nativeName: 'עברית',\n    },\n    hz: {\n        name: 'Herero',\n        nativeName: 'Otjiherero',\n    },\n    hi: {\n        name: 'Hindi',\n        nativeName: 'हिन्दी, हिंदी',\n    },\n    ho: {\n        name: 'Hiri Motu',\n        nativeName: 'Hiri Motu',\n    },\n    hu: {\n        name: 'Hungarian',\n        nativeName: 'Magyar',\n    },\n    ia: {\n        name: 'Interlingua',\n        nativeName: 'Interlingua',\n    },\n    id: {\n        name: 'Indonesian',\n        nativeName: 'Bahasa Indonesia',\n    },\n    ie: {\n        name: 'Interlingue',\n        nativeName: 'Originally called Occidental; then Interlingue after WWII',\n    },\n    ga: {\n        name: 'Irish',\n        nativeName: 'Gaeilge',\n    },\n    ig: {\n        name: 'Igbo',\n        nativeName: 'Asụsụ Igbo',\n    },\n    ik: {\n        name: 'Inupiaq',\n        nativeName: 'Iñupiaq, Iñupiatun',\n    },\n    io: {\n        name: 'Ido',\n        nativeName: 'Ido',\n    },\n    is: {\n        name: 'Icelandic',\n        nativeName: 'Íslenska',\n    },\n    it: {\n        name: 'Italian',\n        nativeName: 'Italiano',\n    },\n    iu: {\n        name: 'Inuktitut',\n        nativeName: 'ᐃᓄᒃᑎᑐᑦ',\n    },\n    ja: {\n        name: 'Japanese',\n        nativeName: '日本語',\n    },\n    jv: {\n        name: 'Javanese',\n        nativeName: 'basa Jawa',\n    },\n    kl: {\n        name: 'Kalaallisut, Greenlandic',\n        nativeName: 'kalaallisut, kalaallit oqaasii',\n    },\n    kn: {\n        name: 'Kannada',\n        nativeName: 'ಕನ್ನಡ',\n    },\n    // \"kr\": {\n    //     \"name\": \"Kanuri\",\n    //     \"nativeName\": \"Kanuri\"\n    // },\n    ks: {\n        name: 'Kashmiri',\n        nativeName: 'कश्मीरी, كشميري‎',\n    },\n    kk: {\n        name: 'Kazakh',\n        nativeName: 'Қазақ тілі',\n    },\n    km: {\n        name: 'Khmer',\n        nativeName: 'ភាសាខ្មែរ',\n    },\n    ki: {\n        name: 'Kikuyu, Gikuyu',\n        nativeName: 'Gĩkũyũ',\n    },\n    rw: {\n        name: 'Kinyarwanda',\n        nativeName: 'Ikinyarwanda',\n    },\n    ky: {\n        name: 'Kirghiz, Kyrgyz',\n        nativeName: 'кыргыз тили',\n    },\n    kv: {\n        name: 'Komi',\n        nativeName: 'коми кыв',\n    },\n    kg: {\n        name: 'Kongo',\n        nativeName: 'KiKongo',\n    },\n    kr: {\n        name: 'Korean',\n        nativeName: '한국어',\n    },\n    ku: {\n        name: 'Kurdish',\n        nativeName: 'Kurdî, كوردی‎',\n    },\n    kj: {\n        name: 'Kwanyama, Kuanyama',\n        nativeName: 'Kuanyama',\n    },\n    la: {\n        name: 'Latin',\n        nativeName: 'latine, lingua latina',\n    },\n    lb: {\n        name: 'Luxembourgish, Letzeburgesch',\n        nativeName: 'Lëtzebuergesch',\n    },\n    lg: {\n        name: 'Luganda',\n        nativeName: 'Luganda',\n    },\n    li: {\n        name: 'Limburgish, Limburgan, Limburger',\n        nativeName: 'Limburgs',\n    },\n    ln: {\n        name: 'Lingala',\n        nativeName: 'Lingála',\n    },\n    lo: {\n        name: 'Lao',\n        nativeName: 'ພາສາລາວ',\n    },\n    lt: {\n        name: 'Lithuanian',\n        nativeName: 'lietuvių kalba',\n    },\n    lu: {\n        name: 'Luba-Katanga',\n        nativeName: '',\n    },\n    lv: {\n        name: 'Latvian',\n        nativeName: 'latviešu valoda',\n    },\n    gv: {\n        name: 'Manx',\n        nativeName: 'Gaelg, Gailck',\n    },\n    mk: {\n        name: 'Macedonian',\n        nativeName: 'македонски јазик',\n    },\n    mg: {\n        name: 'Malagasy',\n        nativeName: 'Malagasy fiteny',\n    },\n    ms: {\n        name: 'Malay',\n        nativeName: 'bahasa Melayu, بهاس ملايو‎',\n    },\n    ml: {\n        name: 'Malayalam',\n        nativeName: 'മലയാളം',\n    },\n    mt: {\n        name: 'Maltese',\n        nativeName: 'Malti',\n    },\n    mi: {\n        name: 'Māori',\n        nativeName: 'te reo Māori',\n    },\n    mr: {\n        name: 'Marathi (Marāṭhī)',\n        nativeName: 'मराठी',\n    },\n    mh: {\n        name: 'Marshallese',\n        nativeName: 'Kajin M̧ajeļ',\n    },\n    mn: {\n        name: 'Mongolian',\n        nativeName: 'монгол',\n    },\n    na: {\n        name: 'Nauru',\n        nativeName: 'Ekakairũ Naoero',\n    },\n    nv: {\n        name: 'Navajo, Navaho',\n        nativeName: 'Diné bizaad, Dinékʼehǰí',\n    },\n    nb: {\n        name: 'Norwegian Bokmål',\n        nativeName: 'Norsk bokmål',\n    },\n    nd: {\n        name: 'North Ndebele',\n        nativeName: 'isiNdebele',\n    },\n    ne: {\n        name: 'Nepali',\n        nativeName: 'नेपाली',\n    },\n    ng: {\n        name: 'Ndonga',\n        nativeName: 'Owambo',\n    },\n    nn: {\n        name: 'Norwegian Nynorsk',\n        nativeName: 'Norsk nynorsk',\n    },\n    no: {\n        name: 'Norwegian',\n        nativeName: 'Norsk',\n    },\n    ii: {\n        name: 'Nuosu',\n        nativeName: 'ꆈꌠ꒿ Nuosuhxop',\n    },\n    nr: {\n        name: 'South Ndebele',\n        nativeName: 'isiNdebele',\n    },\n    oc: {\n        name: 'Occitan',\n        nativeName: 'Occitan',\n    },\n    oj: {\n        name: 'Ojibwe, Ojibwa',\n        nativeName: 'ᐊᓂᔑᓈᐯᒧᐎᓐ',\n    },\n    cu: {\n        name: 'Old Church Slavonic, Church Slavic, Church Slavonic, Old Bulgarian, Old Slavonic',\n        nativeName: 'ѩзыкъ словѣньскъ',\n    },\n    om: {\n        name: 'Oromo',\n        nativeName: 'Afaan Oromoo',\n    },\n    or: {\n        name: 'Oriya',\n        nativeName: 'ଓଡ଼ିଆ',\n    },\n    os: {\n        name: 'Ossetian, Ossetic',\n        nativeName: 'ирон æвзаг',\n    },\n    pa: {\n        name: 'Panjabi, Punjabi',\n        nativeName: 'ਪੰਜਾਬੀ, پنجابی‎',\n    },\n    pi: {\n        name: 'Pāli',\n        nativeName: 'पाऴि',\n    },\n    fa: {\n        name: 'Persian',\n        nativeName: 'فارسی',\n    },\n    pl: {\n        name: 'Polish',\n        nativeName: 'polski',\n    },\n    ps: {\n        name: 'Pashto, Pushto',\n        nativeName: 'پښتو',\n    },\n    pt: {\n        name: 'Portuguese',\n        nativeName: 'Português',\n    },\n    qu: {\n        name: 'Quechua',\n        nativeName: 'Runa Simi, Kichwa',\n    },\n    rm: {\n        name: 'Romansh',\n        nativeName: 'rumantsch grischun',\n    },\n    rn: {\n        name: 'Kirundi',\n        nativeName: 'kiRundi',\n    },\n    ro: {\n        name: 'Romanian, Moldavian, Moldovan',\n        nativeName: 'română',\n    },\n    ru: {\n        name: 'Russian',\n        nativeName: 'русский язык',\n    },\n    sa: {\n        name: 'Sanskrit (Saṁskṛta)',\n        nativeName: 'संस्कृतम्',\n    },\n    sc: {\n        name: 'Sardinian',\n        nativeName: 'sardu',\n    },\n    sd: {\n        name: 'Sindhi',\n        nativeName: 'सिन्धी, سنڌي، سندھی‎',\n    },\n    se: {\n        name: 'Northern Sami',\n        nativeName: 'Davvisámegiella',\n    },\n    sm: {\n        name: 'Samoan',\n        nativeName: 'gagana faa Samoa',\n    },\n    sg: {\n        name: 'Sango',\n        nativeName: 'yângâ tî sängö',\n    },\n    sr: {\n        name: 'Serbian',\n        nativeName: 'српски језик',\n    },\n    gd: {\n        name: 'Scottish Gaelic; Gaelic',\n        nativeName: 'Gàidhlig',\n    },\n    sn: {\n        name: 'Shona',\n        nativeName: 'chiShona',\n    },\n    si: {\n        name: 'Sinhala, Sinhalese',\n        nativeName: 'සිංහල',\n    },\n    sk: {\n        name: 'Slovak',\n        nativeName: 'slovenčina',\n    },\n    sl: {\n        name: 'Slovene',\n        nativeName: 'slovenščina',\n    },\n    so: {\n        name: 'Somali',\n        nativeName: 'Soomaaliga, af Soomaali',\n    },\n    st: {\n        name: 'Southern Sotho',\n        nativeName: 'Sesotho',\n    },\n    es: {\n        name: 'Spanish; Castilian',\n        nativeName: 'Español',\n    },\n    su: {\n        name: 'Sundanese',\n        nativeName: 'Basa Sunda',\n    },\n    sw: {\n        name: 'Swahili',\n        nativeName: 'Kiswahili',\n    },\n    ss: {\n        name: 'Swati',\n        nativeName: 'SiSwati',\n    },\n    sv: {\n        name: 'Swedish',\n        nativeName: 'svenska',\n    },\n    ta: {\n        name: 'Tamil',\n        nativeName: 'தமிழ்',\n    },\n    te: {\n        name: 'Telugu',\n        nativeName: 'తెలుగు',\n    },\n    tg: {\n        name: 'Tajik',\n        nativeName: 'тоҷикӣ, toğikī, تاجیکی‎',\n    },\n    th: {\n        name: 'Thai',\n        nativeName: 'ไทย',\n    },\n    ti: {\n        name: 'Tigrinya',\n        nativeName: 'ትግርኛ',\n    },\n    bo: {\n        name: 'Tibetan Standard, Tibetan, Central',\n        nativeName: 'བོད་ཡིག',\n    },\n    tk: {\n        name: 'Turkmen',\n        nativeName: 'Türkmen, Түркмен',\n    },\n    tl: {\n        name: 'Tagalog',\n        nativeName: 'Wikang Tagalog, ᜏᜒᜃᜅ᜔ ᜆᜄᜎᜓᜄ᜔',\n    },\n    tn: {\n        name: 'Tswana',\n        nativeName: 'Setswana',\n    },\n    to: {\n        name: 'Tonga (Tonga Islands)',\n        nativeName: 'faka Tonga',\n    },\n    tr: {\n        name: 'Turkish',\n        nativeName: 'Türkçe',\n    },\n    ts: {\n        name: 'Tsonga',\n        nativeName: 'Xitsonga',\n    },\n    tt: {\n        name: 'Tatar',\n        nativeName: 'татарча, tatarça, تاتارچا‎',\n    },\n    tw: {\n        name: 'Twi',\n        nativeName: 'Twi',\n    },\n    ty: {\n        name: 'Tahitian',\n        nativeName: 'Reo Tahiti',\n    },\n    ug: {\n        name: 'Uighur, Uyghur',\n        nativeName: 'Uyƣurqə, ئۇيغۇرچە‎',\n    },\n    uk: {\n        name: 'Ukrainian',\n        nativeName: 'українська',\n    },\n    ur: {\n        name: 'Urdu',\n        nativeName: 'اردو',\n    },\n    uz: {\n        name: 'Uzbek',\n        nativeName: 'zbek, Ўзбек, أۇزبېك‎',\n    },\n    ve: {\n        name: 'Venda',\n        nativeName: 'Tshivenḓa',\n    },\n    vn: {\n        name: 'Vietnamese',\n        nativeName: 'Tiếng Việt',\n    },\n    vo: {\n        name: 'Volapük',\n        nativeName: 'Volapük',\n    },\n    wa: {\n        name: 'Walloon',\n        nativeName: 'Walon',\n    },\n    cy: {\n        name: 'Welsh',\n        nativeName: 'Cymraeg',\n    },\n    wo: {\n        name: 'Wolof',\n        nativeName: 'Wollof',\n    },\n    fy: {\n        name: 'Western Frisian',\n        nativeName: 'Frysk',\n    },\n    xh: {\n        name: 'Xhosa',\n        nativeName: 'isiXhosa',\n    },\n    yi: {\n        name: 'Yiddish',\n        nativeName: 'ייִדיש',\n    },\n    yo: {\n        name: 'Yoruba',\n        nativeName: 'Yorùbá',\n    },\n    za: {\n        name: 'Zhuang, Chuang',\n        nativeName: 'Saɯ cueŋƅ, Saw cuengh',\n    },\n}\n\nexport default isoLangs\n","import CryptoJS from 'crypto-js/core'\nimport AES from 'crypto-js/aes'\nconst randomstring = require('randomstring')\nimport * as bip39 from 'bip39'\n\n// The purpose of this class is for obfuscation only rather than secure encryption\nexport default class MnemonicPhrase {\n    private pass: string\n    private encrypted: any\n\n    constructor(mnemonic: string) {\n        if (!bip39.validateMnemonic(mnemonic)) throw new Error('Invalid mnemonic phrase.')\n        this.pass = randomstring.generate(32)\n        this.encrypted = AES.encrypt(mnemonic, this.pass).toString()\n    }\n\n    public getValue() {\n        let decrypted = AES.decrypt(this.encrypted, this.pass).toString(CryptoJS.enc.Utf8)\n        if (!bip39.validateMnemonic(decrypted)) throw new Error('Decrypted mnemonic is not valid.')\n        return decrypted\n    }\n}\n","import { UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm/utxos'\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm/utxos'\nimport { avm, cChain, pChain } from '@/AVA'\nimport { BN } from 'avalanche'\n\nexport async function getStakeForAddresses(addrs: string[]): Promise<BN> {\n    if (addrs.length <= 256) {\n        let stakeData = await pChain.getStake(addrs)\n        return stakeData.staked\n    } else {\n        //Break the list in to 1024 chunks\n        let chunk = addrs.slice(0, 256)\n        let remainingChunk = addrs.slice(256)\n\n        let stakeData = await pChain.getStake(chunk)\n        let chunkStake = stakeData.staked\n        return chunkStake.add(await getStakeForAddresses(remainingChunk))\n    }\n}\n\nexport async function avmGetAllUTXOs(addrs: string[]): Promise<AVMUTXOSet> {\n    if (addrs.length <= 1024) {\n        let utxos = await avmGetAllUTXOsForAddresses(addrs)\n        return utxos\n    } else {\n        //Break the list in to 1024 chunks\n        let chunk = addrs.slice(0, 1024)\n        let remainingChunk = addrs.slice(1024)\n\n        let newSet = await avmGetAllUTXOsForAddresses(chunk)\n        return newSet.merge(await avmGetAllUTXOs(remainingChunk))\n    }\n}\n\nexport async function avmGetAllUTXOsForAddresses(\n    addrs: string[],\n    endIndex: any = undefined\n): Promise<AVMUTXOSet> {\n    if (addrs.length > 1024) throw new Error('Maximum length of addresses is 1024')\n    let response\n    if (!endIndex) {\n        response = await avm.getUTXOs(addrs)\n    } else {\n        response = await avm.getUTXOs(addrs, undefined, 0, endIndex)\n    }\n\n    let utxoSet = response.utxos\n    let utxos = utxoSet.getAllUTXOs()\n    let nextEndIndex = response.endIndex\n    let len = response.numFetched\n\n    if (len >= 1024) {\n        let subUtxos = await avmGetAllUTXOsForAddresses(addrs, nextEndIndex)\n        return utxoSet.merge(subUtxos)\n    }\n    return utxoSet\n}\n\n// helper method to get utxos for more than 1024 addresses\nexport async function platformGetAllUTXOs(addrs: string[]): Promise<PlatformUTXOSet> {\n    if (addrs.length <= 1024) {\n        let newSet = await platformGetAllUTXOsForAddresses(addrs)\n        return newSet\n    } else {\n        //Break the list in to 1024 chunks\n        let chunk = addrs.slice(0, 1024)\n        let remainingChunk = addrs.slice(1024)\n\n        let newSet = await platformGetAllUTXOsForAddresses(chunk)\n\n        return newSet.merge(await platformGetAllUTXOs(remainingChunk))\n    }\n}\n\nexport async function platformGetAllUTXOsForAddresses(\n    addrs: string[],\n    endIndex: any = undefined\n): Promise<PlatformUTXOSet> {\n    let response\n    if (!endIndex) {\n        response = await pChain.getUTXOs(addrs)\n    } else {\n        response = await pChain.getUTXOs(addrs, undefined, 0, endIndex)\n    }\n\n    let utxoSet = response.utxos\n    let nextEndIndex = response.endIndex\n    let len = response.numFetched\n\n    if (len >= 1024) {\n        let subUtxos = await platformGetAllUTXOsForAddresses(addrs, nextEndIndex)\n        return utxoSet.merge(subUtxos)\n    }\n\n    return utxoSet\n}\n","import { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { ITransaction } from '@/components/wallet/transfer/types'\nimport { digestMessage } from '@/helpers/helper'\nimport { WalletNameType } from '@/js/wallets/types'\n\nimport { Buffer as BufferAvalanche, BN } from 'avalanche'\nimport {\n    KeyPair as AVMKeyPair,\n    KeyChain as AVMKeyChain,\n    UTXOSet as AVMUTXOSet,\n    UTXO,\n    UnsignedTx,\n} from 'avalanche/dist/apis/avm'\nimport {\n    KeyPair as PlatformKeyPair,\n    KeyChain as PlatformKeyChain,\n    UTXOSet as PlatformUTXOSet,\n    UTXOSet,\n} from 'avalanche/dist/apis/platformvm'\nimport { KeyChain, KeyChain as EVMKeyChain, UTXOSet as EVMUTXOSet } from 'avalanche/dist/apis/evm'\nimport { PayloadBase } from 'avalanche/dist/utils'\nimport { buildUnsignedTransaction } from '../TxHelper'\nimport { AvaWalletCore, UnsafeWallet } from './types'\nimport { UTXO as PlatformUTXO } from 'avalanche/dist/apis/platformvm/utxos'\nimport { privateToAddress } from 'ethereumjs-util'\nimport { Tx as AVMTx, UnsignedTx as AVMUnsignedTx } from 'avalanche/dist/apis/avm/tx'\nimport {\n    Tx as PlatformTx,\n    UnsignedTx as PlatformUnsignedTx,\n} from 'avalanche/dist/apis/platformvm/tx'\nimport { Tx as EvmTx, UnsignedTx as EVMUnsignedTx } from 'avalanche/dist/apis/evm/tx'\nimport Erc20Token from '@/js/Erc20Token'\nimport { WalletCore } from '@/js/wallets/WalletCore'\nimport { WalletHelper } from '@/helpers/wallet_helper'\nimport { avmGetAllUTXOs, platformGetAllUTXOs } from '@/helpers/utxo_helper'\nimport { UTXO as AVMUTXO } from 'avalanche/dist/apis/avm/utxos'\nimport { Transaction } from '@ethereumjs/tx'\nimport { ExportChainsC, ExportChainsP, ExportChainsX } from '@avalabs/avalanche-wallet-sdk'\n\nclass SingletonWallet extends WalletCore implements AvaWalletCore, UnsafeWallet {\n    keyChain: AVMKeyChain\n    keyPair: AVMKeyPair\n\n    platformKeyChain: PlatformKeyChain\n    platformKeyPair: PlatformKeyPair\n\n    chainId: string\n    chainIdP: string\n\n    key: string\n\n    stakeAmount: BN\n\n    type: WalletNameType\n\n    ethKey: string\n    ethKeyBech: string\n    ethKeyChain: EVMKeyChain\n    ethAddress: string\n    ethAddressBech: string\n    ethBalance: BN\n\n    constructor(pk: string) {\n        super()\n\n        this.key = pk\n\n        this.chainId = avm.getBlockchainAlias() || avm.getBlockchainID()\n        this.chainIdP = pChain.getBlockchainAlias() || pChain.getBlockchainID()\n\n        let hrp = ava.getHRP()\n\n        this.keyChain = new AVMKeyChain(hrp, this.chainId)\n        this.keyPair = this.keyChain.importKey(pk)\n\n        this.platformKeyChain = new PlatformKeyChain(hrp, this.chainIdP)\n        this.platformKeyPair = this.platformKeyChain.importKey(pk)\n\n        this.stakeAmount = new BN(0)\n\n        // Derive EVM key and address\n        let pkBuf = bintools.cb58Decode(pk.split('-')[1])\n        let pkHex = pkBuf.toString('hex')\n        let pkBuffNative = Buffer.from(pkHex, 'hex')\n\n        this.ethKey = pkHex\n        this.ethAddress = privateToAddress(pkBuffNative).toString('hex')\n        this.ethBalance = new BN(0)\n\n        let cPrivKey = `PrivateKey-` + bintools.cb58Encode(BufferAvalanche.from(pkBuf))\n        this.ethKeyBech = cPrivKey\n        let cKeyChain = new KeyChain(ava.getHRP(), 'C')\n        this.ethKeyChain = cKeyChain\n\n        let cKeypair = cKeyChain.importKey(cPrivKey)\n        this.ethAddressBech = cKeypair.getAddressString()\n\n        this.type = 'singleton'\n        this.isInit = true\n    }\n\n    getChangeAddressAvm(): string {\n        return this.getCurrentAddressAvm()\n    }\n\n    getCurrentAddressAvm(): string {\n        return this.keyPair.getAddressString()\n    }\n\n    getChangeAddressPlatform(): string {\n        return this.getCurrentAddressPlatform()\n    }\n\n    getDerivedAddresses(): string[] {\n        let addr = this.getCurrentAddressAvm()\n        return [addr]\n    }\n\n    getDerivedAddressesP() {\n        return [this.getCurrentAddressPlatform()]\n    }\n\n    getAllDerivedExternalAddresses(): string[] {\n        return this.getDerivedAddresses()\n    }\n\n    getExtendedPlatformAddresses(): string[] {\n        let addr = this.platformKeyPair.getAddressString()\n        return [addr]\n    }\n\n    getHistoryAddresses(): string[] {\n        let addr = this.getCurrentAddressAvm()\n        return [addr]\n    }\n\n    getPlatformRewardAddress(): string {\n        return this.getCurrentAddressPlatform()\n    }\n\n    getCurrentAddressPlatform(): string {\n        return this.platformKeyPair.getAddressString()\n    }\n\n    getBaseAddress(): string {\n        return this.getCurrentAddressAvm()\n    }\n\n    async getStake(): Promise<BN> {\n        this.stakeAmount = await WalletHelper.getStake(this)\n        return this.stakeAmount\n    }\n\n    getPlatformUTXOSet(): PlatformUTXOSet {\n        return this.platformUtxoset\n    }\n\n    getEvmAddress(): string {\n        return this.ethAddress\n    }\n\n    getEvmAddressBech(): string {\n        return this.ethAddressBech\n    }\n\n    async getEthBalance() {\n        let bal = await WalletHelper.getEthBalance(this)\n        this.ethBalance = bal\n        return bal\n    }\n\n    async updateUTXOsX(): Promise<AVMUTXOSet> {\n        let result = await avmGetAllUTXOs([this.getCurrentAddressAvm()])\n        this.utxoset = result\n        return result\n    }\n\n    async updateUTXOsP(): Promise<PlatformUTXOSet> {\n        let result = await platformGetAllUTXOs([this.getCurrentAddressPlatform()])\n        this.platformUtxoset = result\n        return result\n    }\n\n    async getUTXOs(): Promise<void> {\n        this.isFetchUtxos = true\n\n        await this.updateUTXOsX()\n        await this.updateUTXOsP()\n\n        await this.getStake()\n        await this.getEthBalance()\n\n        this.isFetchUtxos = false\n\n        return\n    }\n\n    async buildUnsignedTransaction(\n        orders: (ITransaction | UTXO)[],\n        addr: string,\n        memo?: BufferAvalanche\n    ) {\n        const changeAddress = this.getChangeAddressAvm()\n        const derivedAddresses = this.getDerivedAddresses()\n        const utxoset = this.getUTXOSet() as AVMUTXOSet\n\n        return buildUnsignedTransaction(\n            orders,\n            addr,\n            derivedAddresses,\n            utxoset,\n            changeAddress,\n            memo\n        )\n    }\n\n    async issueBatchTx(\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: BufferAvalanche | undefined\n    ): Promise<string> {\n        return await WalletHelper.issueBatchTx(this, orders, addr, memo)\n    }\n\n    getFirstAvailableAddressPlatform(): string {\n        return this.getCurrentAddressPlatform()\n    }\n\n    onnetworkchange(): void {\n        let hrp = ava.getHRP()\n\n        this.keyChain = new AVMKeyChain(hrp, this.chainId)\n        this.utxoset = new AVMUTXOSet()\n        this.keyPair = this.keyChain.importKey(this.key)\n\n        this.platformKeyChain = new PlatformKeyChain(hrp, this.chainIdP)\n        this.platformUtxoset = new PlatformUTXOSet()\n        this.platformKeyPair = this.platformKeyChain.importKey(this.key)\n\n        // Update EVM values\n        this.ethKeyChain = new EVMKeyChain(ava.getHRP(), 'C')\n        let cKeypair = this.ethKeyChain.importKey(this.ethKeyBech)\n        this.ethAddressBech = cKeypair.getAddressString()\n        this.ethBalance = new BN(0)\n\n        this.getUTXOs()\n    }\n\n    async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx> {\n        let keychain = this.keyChain\n\n        const tx = unsignedTx.sign(keychain)\n        return tx\n    }\n\n    async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx> {\n        let keychain = this.platformKeyChain\n        const tx = unsignedTx.sign(keychain)\n        return tx\n    }\n\n    async signC(unsignedTx: EVMUnsignedTx): Promise<EvmTx> {\n        let keyChain = this.ethKeyChain\n        return unsignedTx.sign(keyChain)\n    }\n\n    async signEvm(tx: Transaction) {\n        let keyBuff = Buffer.from(this.ethKey, 'hex')\n        return tx.sign(keyBuff)\n    }\n\n    async signMessage(msgStr: string): Promise<string> {\n        let digest = digestMessage(msgStr)\n\n        let digestHex = digest.toString('hex')\n        let digestBuff = BufferAvalanche.from(digestHex, 'hex')\n        let signed = this.keyPair.sign(digestBuff)\n\n        return bintools.cb58Encode(signed)\n    }\n\n    async delegate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.delegate(this, nodeID, amt, start, end, rewardAddress, utxos)\n    }\n\n    async validate(\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number = 0,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        return await WalletHelper.validate(\n            this,\n            nodeID,\n            amt,\n            start,\n            end,\n            delegationFee,\n            rewardAddress,\n            utxos\n        )\n    }\n\n    async createNftFamily(name: string, symbol: string, groupNum: number) {\n        return await WalletHelper.createNftFamily(this, name, symbol, groupNum)\n    }\n\n    async mintNft(mintUtxo: AVMUTXO, payload: PayloadBase, quantity: number) {\n        return await WalletHelper.mintNft(this, mintUtxo, payload, quantity)\n    }\n\n    async sendEth(to: string, amount: BN, gasPrice: BN, gasLimit: number) {\n        return await WalletHelper.sendEth(this, to, amount, gasPrice, gasLimit)\n    }\n\n    async estimateGas(to: string, amount: BN, token: Erc20Token): Promise<number> {\n        return await WalletHelper.estimateGas(this, to, amount, token)\n    }\n\n    async sendERC20(\n        to: string,\n        amount: BN,\n        gasPrice: BN,\n        gasLimit: number,\n        token: Erc20Token\n    ): Promise<string> {\n        return await WalletHelper.sendErc20(this, to, amount, gasPrice, gasLimit, token)\n    }\n\n    getAllAddressesX() {\n        return [this.getCurrentAddressAvm()]\n    }\n\n    getAllAddressesP() {\n        return [this.getCurrentAddressPlatform()]\n    }\n}\n\nexport { SingletonWallet }\n","class AvaNftFamily {\n    id: string\n    name: string\n    symbol: string\n\n    constructor(id: string, name: string, symbol: string) {\n        this.id = id\n        this.name = name\n        this.symbol = symbol\n    }\n}\n\nexport { AvaNftFamily }\n","/*\nThe base wallet class used for common functionality\n*/\nimport { BN } from 'avalanche'\nimport { UTXOSet as AVMUTXOSet } from 'avalanche/dist/apis/avm'\nimport { UTXOSet as PlatformUTXOSet } from 'avalanche/dist/apis/platformvm'\nimport {\n    ExportChainsC,\n    ExportChainsP,\n    ExportChainsX,\n    Network,\n    UtxoHelper,\n    TxHelper,\n    GasHelper,\n} from '@avalabs/avalanche-wallet-sdk'\nimport { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport { UTXOSet as EVMUTXOSet } from 'avalanche/dist/apis/evm/utxos'\nimport { Tx as EVMTx, UnsignedTx as EVMUnsignedTx } from 'avalanche/dist/apis/evm/tx'\nimport {\n    Tx as PlatformTx,\n    UnsignedTx as PlatformUnsignedTx,\n} from 'avalanche/dist/apis/platformvm/tx'\nimport { Tx as AVMTx, UnsignedTx as AVMUnsignedTx } from 'avalanche/dist/apis/avm/tx'\nimport { AvmImportChainType, WalletType } from '@/js/wallets/types'\nvar uniqid = require('uniqid')\n\nabstract class WalletCore {\n    id: string\n\n    utxoset: AVMUTXOSet\n    platformUtxoset: PlatformUTXOSet\n    stakeAmount: BN\n\n    isFetchUtxos: boolean\n    isInit: boolean\n\n    abstract getEvmAddressBech(): string\n    abstract getEvmAddress(): string\n    abstract getCurrentAddressAvm(): string\n    abstract getChangeAddressAvm(): string\n    abstract getCurrentAddressPlatform(): string\n    abstract getAllAddressesP(): string[]\n    abstract getAllAddressesX(): string[]\n\n    abstract async signC(unsignedTx: EVMUnsignedTx): Promise<EVMTx>\n    abstract async signX(unsignedTx: AVMUnsignedTx): Promise<AVMTx>\n    abstract async signP(unsignedTx: PlatformUnsignedTx): Promise<PlatformTx>\n\n    abstract async signMessage(msg: string, address?: string): Promise<string>\n    abstract getPlatformUTXOSet(): PlatformUTXOSet\n\n    getUTXOSet(): AVMUTXOSet {\n        return this.utxoset\n    }\n\n    protected constructor() {\n        this.id = uniqid()\n        this.utxoset = new AVMUTXOSet()\n        this.platformUtxoset = new PlatformUTXOSet()\n        this.stakeAmount = new BN(0)\n\n        this.isInit = false\n        this.isFetchUtxos = false\n    }\n\n    async evmGetAtomicUTXOs(sourceChain: ExportChainsC) {\n        let addrs = [this.getEvmAddressBech()]\n        return await UtxoHelper.evmGetAtomicUTXOs(addrs, sourceChain)\n    }\n\n    async createImportTxC(sourceChain: ExportChainsC, utxoSet: EVMUTXOSet, fee: BN) {\n        let bechAddr = this.getEvmAddressBech()\n        let hexAddr = this.getEvmAddress()\n\n        let toAddress = '0x' + hexAddr\n        let ownerAddresses = [bechAddr]\n        let fromAddresses = ownerAddresses\n        const sourceChainId = Network.chainIdFromAlias(sourceChain)\n\n        return await cChain.buildImportTx(\n            utxoSet,\n            toAddress,\n            ownerAddresses,\n            sourceChainId,\n            fromAddresses,\n            fee\n        )\n    }\n\n    /**\n     *\n     * @param sourceChain\n     * @param fee Fee to use in nAVAX\n     * @param utxoSet\n     */\n    async importToCChain(sourceChain: ExportChainsC, fee: BN, utxoSet?: EVMUTXOSet) {\n        if (!utxoSet) {\n            utxoSet = await this.evmGetAtomicUTXOs(sourceChain)\n        }\n\n        // TODO: Only use AVAX utxos\n        // TODO?: If the import fee for a utxo is greater than the value of the utxo, ignore it\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        const unsignedTxFee = await this.createImportTxC(sourceChain, utxoSet, fee)\n        let tx = await this.signC(unsignedTxFee)\n        let id = await cChain.issueTx(tx.toString())\n\n        return id\n    }\n\n    async exportFromXChain(amt: BN, destinationChain: ExportChainsX, importFee?: BN) {\n        if (destinationChain === 'C' && !importFee)\n            throw new Error('Exports to C chain must specify an import fee.')\n\n        let amtFee = amt.clone()\n\n        // Get destination address\n        let destinationAddr =\n            destinationChain === 'P' ? this.getCurrentAddressPlatform() : this.getEvmAddressBech()\n\n        // Add import fee to transaction\n        if (importFee) {\n            amtFee = amt.add(importFee)\n        } else if (destinationChain === 'P') {\n            let fee = pChain.getTxFee()\n            amtFee = amt.add(fee)\n        }\n\n        let fromAddresses = this.getAllAddressesX()\n        let changeAddress = this.getChangeAddressAvm()\n        let utxos = this.getUTXOSet()\n        let exportTx = await TxHelper.buildAvmExportTransaction(\n            destinationChain,\n            utxos,\n            fromAddresses,\n            destinationAddr,\n            amtFee,\n            changeAddress\n        )\n\n        let tx = await this.signX(exportTx)\n\n        return avm.issueTx(tx)\n    }\n\n    async exportFromPChain(amt: BN, destinationChain: ExportChainsP, importFee?: BN) {\n        let utxoSet = this.getPlatformUTXOSet()\n\n        let pChangeAddr = this.getCurrentAddressPlatform()\n        let fromAddrs = this.getAllAddressesP()\n\n        if (destinationChain === 'C' && !importFee)\n            throw new Error('Exports to C chain must specify an import fee.')\n\n        // Calculate C chain import fee\n        let amtFee = amt.clone()\n        if (importFee) {\n            amtFee = amt.add(importFee)\n        } else if (destinationChain === 'X') {\n            // We can add the import fee for X chain\n            let fee = avm.getTxFee()\n            amtFee = amt.add(fee)\n        }\n\n        // Get the destination address for the right chain\n        let destinationAddr =\n            destinationChain === 'C' ? this.getEvmAddressBech() : this.getCurrentAddressAvm()\n\n        const exportTx = await TxHelper.buildPlatformExportTransaction(\n            utxoSet,\n            fromAddrs,\n            destinationAddr,\n            amtFee,\n            pChangeAddr,\n            destinationChain\n        )\n\n        let tx = await this.signP(exportTx)\n        return await pChain.issueTx(tx)\n    }\n\n    /**\n     *\n     * @param amt The amount to receive on the destination chain, in nAVAX.\n     * @param destinationChain `X` or `P`\n     * @param fee Fee to use in the export transaction, given in nAVAX.\n     */\n    async exportFromCChain(amt: BN, destinationChain: ExportChainsC, exportFee: BN) {\n        // Add import fee\n        // X and P have the same fee\n        let importFee = avm.getTxFee()\n        let amtFee = amt.add(importFee)\n\n        let hexAddr = this.getEvmAddress()\n        let bechAddr = this.getEvmAddressBech()\n\n        let fromAddresses = [hexAddr]\n\n        let destinationAddr =\n            destinationChain === 'X'\n                ? this.getCurrentAddressAvm()\n                : this.getCurrentAddressPlatform()\n\n        let exportTx = await TxHelper.buildEvmExportTransaction(\n            fromAddresses,\n            destinationAddr,\n            amtFee,\n            bechAddr,\n            destinationChain,\n            exportFee\n        )\n\n        let tx = await this.signC(exportTx)\n        return cChain.issueTx(tx.toString())\n    }\n\n    /**\n     * Returns the estimated gas to export from C chain.\n     * @param destinationChain\n     * @param amount\n     */\n    async estimateExportFee(destinationChain: ExportChainsC, amount: BN): Promise<number> {\n        let hexAddr = this.getEvmAddress()\n        let bechAddr = this.getEvmAddressBech()\n\n        let destinationAddr =\n            destinationChain === 'X'\n                ? this.getCurrentAddressAvm()\n                : this.getCurrentAddressPlatform()\n\n        return GasHelper.estimateExportGasFee(\n            destinationChain,\n            hexAddr,\n            bechAddr,\n            destinationAddr,\n            amount\n        )\n    }\n\n    async avmGetAtomicUTXOs(sourceChain: ExportChainsX) {\n        let addrs = this.getAllAddressesX()\n        return await UtxoHelper.avmGetAtomicUTXOs(addrs, sourceChain)\n    }\n\n    async platformGetAtomicUTXOs(sourceChain: ExportChainsP) {\n        let addrs = this.getAllAddressesP()\n        return await UtxoHelper.platformGetAtomicUTXOs(addrs, sourceChain)\n    }\n\n    async importToPlatformChain(sourceChain: ExportChainsP): Promise<string> {\n        const utxoSet = await this.platformGetAtomicUTXOs(sourceChain)\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        const sourceChainId = Network.chainIdFromAlias(sourceChain)\n        // Owner addresses, the addresses we exported to\n        let pToAddr = this.getCurrentAddressPlatform()\n\n        let hrp = ava.getHRP()\n        let utxoAddrs = utxoSet\n            .getAddresses()\n            .map((addr) => bintools.addressToString(hrp, 'P', addr))\n\n        let fromAddrs = utxoAddrs\n        let ownerAddrs = utxoAddrs\n\n        const unsignedTx = await pChain.buildImportTx(\n            utxoSet,\n            ownerAddrs,\n            sourceChainId,\n            [pToAddr],\n            [pToAddr],\n            [pToAddr],\n            undefined,\n            undefined\n        )\n        const tx = await this.signP(unsignedTx)\n        // Pass in string because AJS fails to verify Tx type\n        return pChain.issueTx(tx.toString())\n    }\n\n    async importToXChain(sourceChain: AvmImportChainType) {\n        const utxoSet = await this.avmGetAtomicUTXOs(sourceChain)\n\n        if (utxoSet.getAllUTXOs().length === 0) {\n            throw new Error('Nothing to import.')\n        }\n\n        let xToAddr = this.getCurrentAddressAvm()\n\n        let hrp = ava.getHRP()\n        let utxoAddrs = utxoSet\n            .getAddresses()\n            .map((addr) => bintools.addressToString(hrp, 'X', addr))\n\n        let fromAddrs = utxoAddrs\n        let ownerAddrs = utxoAddrs\n\n        let sourceChainId = Network.chainIdFromAlias(sourceChain)\n\n        // Owner addresses, the addresses we exported to\n        const unsignedTx = await avm.buildImportTx(\n            utxoSet,\n            ownerAddrs,\n            sourceChainId,\n            [xToAddr],\n            fromAddrs,\n            [xToAddr]\n        )\n\n        const tx = await this.signX(unsignedTx)\n        return await avm.issueTx(tx.toString())\n    }\n}\nexport { WalletCore }\n","import { ava, avm, bintools, cChain, pChain } from '@/AVA'\nimport {\n    UTXOSet as PlatformUTXOSet,\n    UTXO as PlatformUTXO,\n} from 'avalanche/dist/apis/platformvm/utxos'\nimport { UTXO as AVMUTXO } from 'avalanche/dist/apis/avm/utxos'\nimport { WalletType } from '@/js/wallets/types'\n\nimport { BN, Buffer } from 'avalanche'\nimport {\n    buildCreateNftFamilyTx,\n    buildEvmTransferErc20Tx,\n    buildEvmTransferErc721Tx,\n    buildEvmTransferNativeTx,\n    buildMintNftTx,\n} from '@/js/TxHelper'\nimport { PayloadBase } from 'avalanche/dist/utils'\nimport { ITransaction } from '@/components/wallet/transfer/types'\n\nimport { web3 } from '@/evm'\nimport Erc20Token from '@/js/Erc20Token'\nimport { getStakeForAddresses } from '@/helpers/utxo_helper'\nimport ERC721Token from '@/js/ERC721Token'\n\nclass WalletHelper {\n    static async getStake(wallet: WalletType): Promise<BN> {\n        let addrs = wallet.getAllAddressesP()\n        return await getStakeForAddresses(addrs)\n    }\n\n    static async createNftFamily(\n        wallet: WalletType,\n        name: string,\n        symbol: string,\n        groupNum: number\n    ) {\n        let fromAddresses = wallet.getDerivedAddresses()\n        let changeAddress = wallet.getChangeAddressAvm()\n\n        let minterAddress = wallet.getCurrentAddressAvm()\n\n        let utxoSet = wallet.utxoset\n\n        let unsignedTx = await buildCreateNftFamilyTx(\n            name,\n            symbol,\n            groupNum,\n            fromAddresses,\n            minterAddress,\n            changeAddress,\n            utxoSet\n        )\n\n        let signed = await wallet.signX(unsignedTx)\n        return await avm.issueTx(signed)\n    }\n\n    static async mintNft(\n        wallet: WalletType,\n        mintUtxo: AVMUTXO,\n        payload: PayloadBase,\n        quantity: number\n    ) {\n        let ownerAddress = wallet.getCurrentAddressAvm()\n        let changeAddress = wallet.getChangeAddressAvm()\n\n        let sourceAddresses = wallet.getDerivedAddresses()\n\n        let utxoSet = wallet.utxoset\n        let tx = await buildMintNftTx(\n            mintUtxo,\n            payload,\n            quantity,\n            ownerAddress,\n            changeAddress,\n            sourceAddresses,\n            utxoSet\n        )\n        let signed = await wallet.signX(tx)\n        return await avm.issueTx(signed)\n    }\n\n    static async issueBatchTx(\n        wallet: WalletType,\n        orders: (ITransaction | AVMUTXO)[],\n        addr: string,\n        memo: Buffer | undefined\n    ): Promise<string> {\n        let unsignedTx = await wallet.buildUnsignedTransaction(orders, addr, memo)\n        const tx = await wallet.signX(unsignedTx)\n        const txId: string = await avm.issueTx(tx)\n\n        return txId\n    }\n\n    static async validate(\n        wallet: WalletType,\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        delegationFee: number,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        let utxoSet = wallet.getPlatformUTXOSet()\n\n        // If given custom UTXO set use that\n        if (utxos) {\n            utxoSet = new PlatformUTXOSet()\n            utxoSet.addArray(utxos)\n        }\n\n        let pAddressStrings = wallet.getAllAddressesP()\n\n        let stakeAmount = amt\n\n        // If reward address isn't given use index 0 address\n        if (!rewardAddress) {\n            rewardAddress = wallet.getPlatformRewardAddress()\n        }\n\n        // For change address use first available on the platform chain\n        let changeAddress = wallet.getFirstAvailableAddressPlatform()\n\n        let stakeReturnAddr = wallet.getCurrentAddressPlatform()\n\n        // Convert dates to unix time\n        let startTime = new BN(Math.round(start.getTime() / 1000))\n        let endTime = new BN(Math.round(end.getTime() / 1000))\n\n        const unsignedTx = await pChain.buildAddValidatorTx(\n            utxoSet,\n            [stakeReturnAddr],\n            pAddressStrings, // from\n            [changeAddress], // change\n            nodeID,\n            startTime,\n            endTime,\n            stakeAmount,\n            [rewardAddress],\n            delegationFee\n        )\n\n        let tx = await wallet.signP(unsignedTx)\n        return await pChain.issueTx(tx)\n    }\n\n    static async delegate(\n        wallet: WalletType,\n        nodeID: string,\n        amt: BN,\n        start: Date,\n        end: Date,\n        rewardAddress?: string,\n        utxos?: PlatformUTXO[]\n    ): Promise<string> {\n        let utxoSet = wallet.getPlatformUTXOSet()\n        let pAddressStrings = wallet.getAllAddressesP()\n\n        let stakeAmount = amt\n\n        // If given custom UTXO set use that\n        if (utxos) {\n            utxoSet = new PlatformUTXOSet()\n            utxoSet.addArray(utxos)\n        }\n\n        // If reward address isn't given use index 0 address\n        if (!rewardAddress) {\n            rewardAddress = wallet.getPlatformRewardAddress()\n        }\n\n        let stakeReturnAddr = wallet.getPlatformRewardAddress()\n\n        // For change address use first available on the platform chain\n        let changeAddress = wallet.getFirstAvailableAddressPlatform()\n\n        // Convert dates to unix time\n        let startTime = new BN(Math.round(start.getTime() / 1000))\n        let endTime = new BN(Math.round(end.getTime() / 1000))\n\n        const unsignedTx = await pChain.buildAddDelegatorTx(\n            utxoSet,\n            [stakeReturnAddr],\n            pAddressStrings,\n            [changeAddress],\n            nodeID,\n            startTime,\n            endTime,\n            stakeAmount,\n            [rewardAddress] // reward address\n        )\n\n        const tx = await wallet.signP(unsignedTx)\n        return await pChain.issueTx(tx)\n    }\n\n    static async getEthBalance(wallet: WalletType) {\n        let bal = await web3.eth.getBalance(wallet.ethAddress)\n        return new BN(bal)\n    }\n\n    static async sendEth(\n        wallet: WalletType,\n        to: string,\n        amount: BN, // in wei\n        gasPrice: BN,\n        gasLimit: number\n    ) {\n        let fromAddr = '0x' + wallet.getEvmAddress()\n\n        let tx = await buildEvmTransferNativeTx(fromAddr, to, amount, gasPrice, gasLimit)\n\n        let signedTx = await wallet.signEvm(tx)\n\n        let txHex = signedTx.serialize().toString('hex')\n        let hash = await web3.eth.sendSignedTransaction('0x' + txHex)\n        return hash.transactionHash\n    }\n\n    static async sendErc20(\n        wallet: WalletType,\n        to: string,\n        amount: BN,\n        gasPrice: BN,\n        gasLimit: number,\n        token: Erc20Token\n    ) {\n        let fromAddr = '0x' + wallet.getEvmAddress()\n        let tx = await buildEvmTransferErc20Tx(fromAddr, to, amount, gasPrice, gasLimit, token)\n\n        let signedTx = await wallet.signEvm(tx)\n        let txHex = signedTx.serialize().toString('hex')\n        let hash = await web3.eth.sendSignedTransaction('0x' + txHex)\n        return hash.transactionHash\n    }\n\n    static async sendErc721(\n        wallet: WalletType,\n        to: string,\n        gasPrice: BN,\n        gasLimit: number,\n        token: ERC721Token,\n        tokenId: string\n    ) {\n        let fromAddr = '0x' + wallet.getEvmAddress()\n        let tx = await buildEvmTransferErc721Tx(fromAddr, to, gasPrice, gasLimit, token, tokenId)\n        let signedTx = await wallet.signEvm(tx)\n        let txHex = signedTx.serialize().toString('hex')\n        let hash = await web3.eth.sendSignedTransaction('0x' + txHex)\n        return hash.transactionHash\n    }\n\n    static async estimateTxGas(wallet: WalletType, tx: any) {\n        let fromAddr = '0x' + wallet.getEvmAddress()\n        let estGas = await tx.estimateGas({ from: fromAddr })\n        return Math.round(estGas * 1.1)\n    }\n\n    static async estimateGas(wallet: WalletType, to: string, amount: BN, token: Erc20Token) {\n        let from = '0x' + wallet.getEvmAddress()\n        let tx = token.createTransferTx(to, amount)\n        let estGas = await tx.estimateGas({\n            from: from,\n        })\n        // Return 10% more\n        return Math.round(estGas * 1.1)\n    }\n}\n\nexport { WalletHelper }\n","import { ava } from '@/AVA'\n\nimport {\n    KeyChain as AVMKeyChain,\n    KeyPair as AVMKeyPair,\n    NFTTransferOutput,\n    UTXO,\n} from 'avalanche/dist/apis/avm'\n\nimport { Defaults, getPreferredHRP, ONEAVAX, PayloadBase, PayloadTypes } from 'avalanche/dist/utils'\nimport Big from 'big.js'\n\nimport { Buffer, BN } from 'avalanche'\nimport createHash from 'create-hash'\n\nfunction bnToBig(val: BN, denomination = 0): Big {\n    return new Big(val.toString()).div(Math.pow(10, denomination))\n}\n\nfunction keyToKeypair(key: string, chainID: string = 'X'): AVMKeyPair {\n    let hrp = getPreferredHRP(ava.getNetworkID())\n    let keychain = new AVMKeyChain(hrp, chainID)\n    return keychain.importKey(key)\n}\n\nfunction calculateStakingReward(amount: BN, duration: number, currentSupply: BN): BN {\n    let networkID = ava.getNetworkID()\n\n    //@ts-ignore\n    let defValues = Defaults.network[networkID]\n\n    if (!defValues) {\n        console.error('Network default values not found.')\n        return new BN(0)\n    }\n    const defPlatformVals = defValues.P\n\n    let maxConsumption: number = defPlatformVals.maxConsumption\n    let minConsumption: number = defPlatformVals.minConsumption\n    let diffConsumption = maxConsumption - minConsumption\n    let maxSupply: BN = defPlatformVals.maxSupply\n    let maxStakingDuration: BN = defPlatformVals.maxStakingDuration\n    let remainingSupply = maxSupply.sub(currentSupply)\n\n    let amtBig = Big(amount.div(ONEAVAX).toString())\n    let currentSupplyBig = Big(currentSupply.div(ONEAVAX).toString())\n    let remainingSupplyBig = Big(remainingSupply.div(ONEAVAX).toString())\n    let portionOfExistingSupplyBig = amtBig.div(currentSupplyBig)\n\n    let portionOfStakingDuration = duration / maxStakingDuration.toNumber()\n    let mintingRate = minConsumption + diffConsumption * portionOfStakingDuration\n\n    let rewardBig: Big = remainingSupplyBig.times(portionOfExistingSupplyBig)\n    rewardBig = rewardBig.times(Big(mintingRate * portionOfStakingDuration))\n\n    let rewardStr = rewardBig.times(Math.pow(10, 9)).toFixed(0)\n    let rewardBN = new BN(rewardStr)\n\n    return rewardBN\n}\n\nfunction digestMessage(msgStr: string) {\n    let mBuf = Buffer.from(msgStr, 'utf8')\n    let msgSize = Buffer.alloc(4)\n    msgSize.writeUInt32BE(mBuf.length, 0)\n    let msgBuf = Buffer.from(`\\x1AAvalanche Signed Message:\\n${msgSize}${msgStr}`, 'utf8')\n    return createHash('sha256').update(msgBuf).digest()\n}\n\nlet payloadtypes = PayloadTypes.getInstance()\n\nfunction getPayloadFromUTXO(utxo: UTXO): PayloadBase {\n    let out = utxo.getOutput() as NFTTransferOutput\n    let payload = out.getPayloadBuffer()\n\n    let typeId = payloadtypes.getTypeID(payload)\n    let pl: Buffer = payloadtypes.getContent(payload)\n    let payloadbase: PayloadBase = payloadtypes.select(typeId, pl)\n\n    return payloadbase\n}\n\nexport { keyToKeypair, calculateStakingReward, bnToBig, digestMessage, getPayloadFromUTXO }\n","// Manages BigNumber and Ava conversion and arithmetic\nimport { BN } from 'avalanche'\nimport Big from 'big.js'\n\nclass AvaAsset {\n    id: string\n    name: string\n    symbol: string\n    denomination: number\n    amount: BN\n    amountLocked: BN\n    // AVAX P chain, Wallet Staking\n    amountExtra: BN\n    private readonly pow: Big\n    constructor(id: string, name: string, symbol: string, denomination: number) {\n        this.id = id\n        this.name = name\n        this.symbol = symbol\n        this.denomination = denomination\n        this.amount = new BN(0, 10)\n        this.amountLocked = new BN(0, 10)\n        this.amountExtra = new BN(0, 10)\n        this.pow = Big(10).pow(denomination)\n    }\n\n    addBalance(val: BN): void {\n        this.amount = this.amount.add(val)\n    }\n\n    addBalanceLocked(val: BN): void {\n        this.amountLocked = this.amountLocked.add(val)\n    }\n\n    addExtra(val: BN): void {\n        this.amountExtra = this.amountExtra.add(val)\n    }\n\n    resetBalance() {\n        this.amount = new BN(0, 10)\n        this.amountLocked = new BN(0, 10)\n        this.amountExtra = new BN(0, 10)\n    }\n\n    getAmount(locked: boolean = false): Big {\n        if (!locked) {\n            return Big(this.amount.toString(10)).div(this.pow)\n        } else {\n            return Big(this.amountLocked.toString(10)).div(this.pow)\n        }\n    }\n\n    getAmountBN(locked: boolean = false): BN {\n        if (!locked) {\n            return this.amount\n        } else {\n            return this.amountLocked\n        }\n    }\n\n    getTotalAmount(): BN {\n        return this.amount.add(this.amountLocked).add(this.amountExtra)\n    }\n\n    toStringTotal(): string {\n        let big: Big = Big(this.getTotalAmount().toString(10)).div(this.pow)\n        return big.toLocaleString(this.denomination)\n    }\n\n    toString() {\n        let big: Big = Big(this.amount.toString(10)).div(this.pow)\n        return big.toLocaleString(this.denomination)\n        // if(big.lt(Big('0.001'))){\n        //     return big.toLocaleString(this.denomination);\n        // }else{\n        //     let min = Math.min(this.denomination, 2);\n        //     return big.toLocaleString(min);\n        // }\n    }\n}\n\nexport default AvaAsset\n"],"sourceRoot":""}